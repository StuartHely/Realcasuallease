import { publicProcedure, protectedProcedure, ownerProcedure, adminProcedure, router } from "../_core/trpc";
import { z } from "zod";
import * as db from "../db";
import { TRPCError } from "@trpc/server";

export const centresRouter = router({
  list: publicProcedure.query(async () => {
    return await db.getShoppingCentres();
  }),
  
  search: publicProcedure
    .input(z.object({ query: z.string() }))
    .query(async ({ input }) => {
      return await db.searchShoppingCentres(input.query);
    }),
  
  getById: publicProcedure
    .input(z.object({ id: z.number() }))
    .query(async ({ input }) => {
      const centre = await db.getShoppingCentreById(input.id);
      if (!centre) throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
      return centre;
    }),
  getBySlug: publicProcedure
    .input(z.object({ slug: z.string() }))
    .query(async ({ input }) => {
      const centre = await db.getShoppingCentreBySlug(input.slug);
      if (!centre) throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
      return centre;
    }),
  getBySlugOrId: publicProcedure
    .input(z.object({ idOrSlug: z.string() }))
    .query(async ({ input }) => {
      const centre = await db.getShoppingCentreByIdOrSlug(input.idOrSlug);
      if (!centre) throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
      return centre;
    }),
  getSites: publicProcedure
    .input(z.object({ centreId: z.number() }))
    .query(async ({ input }) => {
      return await db.getSitesByCentreId(input.centreId);
    }),
  
  getByState: publicProcedure
    .input(z.object({ state: z.string().trim().toUpperCase() }))
    .query(async ({ input }) => {
      return await db.getShoppingCentresByState(input.state);
    }),
  
  getNearby: publicProcedure
    .input(z.object({ 
      centreId: z.number(),
      radiusKm: z.number().optional().default(10),
    }))
    .query(async ({ input }) => {
      return await db.getNearbyCentres(input.centreId, input.radiusKm);
    }),
  
  listWithCodes: ownerProcedure.query(async () => {
    const { generateAbbreviatedCentreCode } = await import('../centreCodeHelper');
    const centres = await db.getShoppingCentres();
    
    return centres.map(centre => ({
      id: centre.id,
      name: centre.name,
      currentCode: centre.centreCode,
      autoGeneratedCode: generateAbbreviatedCentreCode(centre.name),
      state: centre.state,
      city: centre.city,
    }));
  }),
  
  updateCentreCode: adminProcedure
    .input(z.object({
      centreId: z.number(),
      centreCode: z.string().length(4).regex(/^[A-Z]{4}$/, 'Code must be 4 uppercase letters'),
    }))
    .mutation(async ({ input }) => {
      // Check if code is already used by another centre
      const centres = await db.getShoppingCentres();
      const existing = centres.find(c => 
        c.centreCode === input.centreCode && c.id !== input.centreId
      );
      
      if (existing) {
        throw new TRPCError({ 
          code: 'BAD_REQUEST', 
          message: `Code ${input.centreCode} is already used by ${existing.name}` 
        });
      }
      
      await db.updateShoppingCentre(input.centreId, { 
        centreCode: input.centreCode 
      });
      
      return { success: true };
    }),
  
  update: ownerProcedure
    .input(z.object({
      id: z.number(),
      name: z.string().trim().min(1).optional(),
      address: z.string().trim().optional(),
      suburb: z.string().trim().optional(),
      state: z.string().trim().toUpperCase().optional(),
      postcode: z.string().trim().optional(),
      description: z.string().optional(),
      contactPhone: z.string().trim().optional(),
      contactEmail: z.string().email().optional(),
      operatingHours: z.string().optional(),
      policies: z.string().optional(),
      pdfUrl1: z.string().optional(),
      pdfName1: z.string().optional(),
      pdfUrl2: z.string().optional(),
      pdfName2: z.string().optional(),
      pdfUrl3: z.string().optional(),
      pdfName3: z.string().optional(),
    }))
    .mutation(async ({ input, ctx }) => {
      const centre = await db.getShoppingCentreById(input.id);
      if (!centre) {
        throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
      }
      
      // Update centre
      await db.updateShoppingCentre(input.id, input);
      
      return { success: true, message: "Centre updated successfully" };
    }),
  
  uploadPdf: ownerProcedure
    .input(z.object({
      centreId: z.number(),
      slot: z.number().min(1).max(3),
      base64Pdf: z.string(),
      originalName: z.string(),
    }))
    .mutation(async ({ input }) => {
      const { storagePut } = await import('../storage');
      
      // Extract base64 data
      const base64Data = input.base64Pdf.replace(/^data:application\/pdf;base64,/, '');
      const buffer = Buffer.from(base64Data, 'base64');
      
      // Generate unique filename
      const timestamp = Date.now();
      const randomSuffix = Math.random().toString(36).substring(2, 8);
      const safeOriginalName = input.originalName.replace(/[^a-zA-Z0-9.-]/g, '_');
      const fileKey = `centres/${input.centreId}/pdfs/pdf${input.slot}-${timestamp}-${randomSuffix}-${safeOriginalName}`;
      
      // Upload to S3
      const { url } = await storagePut(fileKey, buffer, 'application/pdf');
      
      return { url, originalName: input.originalName };
    }),
  
  updateWeeklyReportSettings: ownerProcedure
    .input(z.object({
      id: z.number(),
      weeklyReportEmail1: z.string().email().nullable().optional(),
      weeklyReportEmail2: z.string().email().nullable().optional(),
      weeklyReportEmail3: z.string().email().nullable().optional(),
      weeklyReportEmail4: z.string().email().nullable().optional(),
      weeklyReportEmail5: z.string().email().nullable().optional(),
      weeklyReportEmail6: z.string().email().nullable().optional(),
      weeklyReportEmail7: z.string().email().nullable().optional(),
      weeklyReportEmail8: z.string().email().nullable().optional(),
      weeklyReportEmail9: z.string().email().nullable().optional(),
      weeklyReportEmail10: z.string().email().nullable().optional(),
      weeklyReportTimezone: z.string().optional(),
      weeklyReportNextOverrideDay: z.enum(["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]).nullable().optional(),
    }))
    .mutation(async ({ input }) => {
      const centre = await db.getShoppingCentreById(input.id);
      if (!centre) {
        throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
      }
      
      await db.updateShoppingCentre(input.id, input);
      return { success: true, message: "Weekly report settings updated successfully" };
    }),
  
  sendTestWeeklyReport: ownerProcedure
    .input(z.object({ centreId: z.number() }))
    .mutation(async ({ input }) => {
      const { triggerWeeklyReport } = await import("../reportScheduler");
      const result = await triggerWeeklyReport(input.centreId);
      
      if (!result.success) {
        throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: result.message });
      }
      
      return { success: true, message: "Test report sent successfully" };
    }),
});
