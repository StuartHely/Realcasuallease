import { COOKIE_NAME } from "@shared/const";
import { getSessionCookieOptions } from "./_core/cookies";
import { systemRouter } from "./_core/systemRouter";
import { publicProcedure, protectedProcedure, router } from "./_core/trpc";
import { z } from "zod";
import * as db from "./db";
import { getSystemConfig as getSystemConfigDb, updateSystemConfig as updateSystemConfigDb, getConfigValue, setConfigValue } from "./systemConfigDb";
import { trackImageView, trackImageClick, getTopPerformingImages, getImageAnalyticsBySite } from "./imageAnalyticsDb";
import { getSeasonalRatesBySiteId, createSeasonalRate, updateSeasonalRate, deleteSeasonalRate } from "./seasonalRatesDb";
import { getAllUsageCategories, getApprovedCategoriesForSite, setApprovedCategoriesForSite, getSitesWithCategoriesForCentre } from "./usageCategoriesDb";
import { TRPCError } from "@trpc/server";
import { notifyOwner } from "./_core/notification";
import { sendBookingConfirmationEmail, sendBookingRejectionEmail, sendNewBookingNotificationToOwner } from "./_core/bookingNotifications";

// Admin-only procedure
const adminProcedure = protectedProcedure.use(({ ctx, next }) => {
  if (ctx.user.role === 'customer') {
    throw new TRPCError({ code: 'FORBIDDEN', message: 'Admin access required' });
  }
  return next({ ctx });
});

export const appRouter = router({
  system: systemRouter,
  
  auth: router({
    me: publicProcedure.query(opts => opts.ctx.user),
    logout: publicProcedure.mutation(({ ctx }) => {
      const cookieOptions = getSessionCookieOptions(ctx.req);
      ctx.res.clearCookie(COOKIE_NAME, { ...cookieOptions, maxAge: -1 });
      return { success: true } as const;
    }),
    checkEmailAvailable: publicProcedure
      .input(z.object({ email: z.string().email() }))
      .query(async ({ input }) => {
        const { getUserByEmail } = await import('./db');
        const existingUser = await getUserByEmail(input.email);
        return { available: !existingUser };
      }),
  }),

  // Shopping Centres
  centres: router({
    list: publicProcedure.query(async () => {
      return await db.getShoppingCentres();
    }),
    
    search: publicProcedure
      .input(z.object({ query: z.string() }))
      .query(async ({ input }) => {
        return await db.searchShoppingCentres(input.query);
      }),
    
    getById: publicProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        const centre = await db.getShoppingCentreById(input.id);
        if (!centre) throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
        return centre;
      }),
    
    getSites: publicProcedure
      .input(z.object({ centreId: z.number() }))
      .query(async ({ input }) => {
        return await db.getSitesByCentreId(input.centreId);
      }),
    
    getByState: publicProcedure
      .input(z.object({ state: z.string() }))
      .query(async ({ input }) => {
        return await db.getShoppingCentresByState(input.state);
      }),
    
    getNearby: publicProcedure
      .input(z.object({ 
        centreId: z.number(),
        radiusKm: z.number().optional().default(10),
      }))
      .query(async ({ input }) => {
        return await db.getNearbyCentres(input.centreId, input.radiusKm);
      }),
    
    listWithCodes: adminProcedure.query(async () => {
      const { generateAbbreviatedCentreCode } = await import('./centreCodeHelper');
      const centres = await db.getShoppingCentres();
      
      return centres.map(centre => ({
        id: centre.id,
        name: centre.name,
        currentCode: centre.centreCode,
        autoGeneratedCode: generateAbbreviatedCentreCode(centre.name),
        state: centre.state,
        city: centre.city,
      }));
    }),
    
    updateCentreCode: adminProcedure
      .input(z.object({
        centreId: z.number(),
        centreCode: z.string().length(4).regex(/^[A-Z]{4}$/, 'Code must be 4 uppercase letters'),
      }))
      .mutation(async ({ input }) => {
        // Check if code is already used by another centre
        const centres = await db.getShoppingCentres();
        const existing = centres.find(c => 
          c.centreCode === input.centreCode && c.id !== input.centreId
        );
        
        if (existing) {
          throw new TRPCError({ 
            code: 'BAD_REQUEST', 
            message: `Code ${input.centreCode} is already used by ${existing.name}` 
          });
        }
        
        await db.updateShoppingCentre(input.centreId, { 
          centreCode: input.centreCode 
        });
        
        return { success: true };
      }),
    
    update: protectedProcedure
      .input(z.object({
        id: z.number(),
        name: z.string().min(1).optional(),
        address: z.string().optional(),
        suburb: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        postcode: z.string().optional(),
        description: z.string().optional(),
        contactPhone: z.string().optional(),
        contactEmail: z.string().email().optional(),
        operatingHours: z.string().optional(),
        policies: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const centre = await db.getShoppingCentreById(input.id);
        if (!centre) {
          throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
        }
        
        // Update centre
        await db.updateShoppingCentre(input.id, input);
        
        return { success: true, message: "Centre updated successfully" };
      }),
    
    updateWeeklyReportSettings: protectedProcedure
      .input(z.object({
        id: z.number(),
        weeklyReportEmail1: z.string().email().nullable().optional(),
        weeklyReportEmail2: z.string().email().nullable().optional(),
        weeklyReportEmail3: z.string().email().nullable().optional(),
        weeklyReportEmail4: z.string().email().nullable().optional(),
        weeklyReportEmail5: z.string().email().nullable().optional(),
        weeklyReportEmail6: z.string().email().nullable().optional(),
        weeklyReportEmail7: z.string().email().nullable().optional(),
        weeklyReportEmail8: z.string().email().nullable().optional(),
        weeklyReportEmail9: z.string().email().nullable().optional(),
        weeklyReportEmail10: z.string().email().nullable().optional(),
        weeklyReportTimezone: z.string().optional(),
        weeklyReportNextOverrideDay: z.enum(["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]).nullable().optional(),
      }))
      .mutation(async ({ input }) => {
        const centre = await db.getShoppingCentreById(input.id);
        if (!centre) {
          throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
        }
        
        await db.updateShoppingCentre(input.id, input);
        return { success: true, message: "Weekly report settings updated successfully" };
      }),
    
    sendTestWeeklyReport: protectedProcedure
      .input(z.object({ centreId: z.number() }))
      .mutation(async ({ input }) => {
        const { triggerWeeklyReport } = await import("./reportScheduler");
        const result = await triggerWeeklyReport(input.centreId);
        
        if (!result.success) {
          throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: result.message });
        }
        
        return { success: true, message: "Test report sent successfully" };
      }),
  }),

  // Sites
  sites: router({
    getByCentreId: publicProcedure
      .input(z.object({ centreId: z.number() }))
      .query(async ({ input }) => {
        return await db.getSitesByCentreId(input.centreId);
      }),
    getById: publicProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        const site = await db.getSiteById(input.id);
        if (!site) throw new TRPCError({ code: "NOT_FOUND", message: "Site not found" });
        return site;
      }),
    
    checkAvailability: publicProcedure
      .input(z.object({
        siteId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
      }))
      .query(async ({ input }) => {
        const bookings = await db.getBookingsBySiteId(input.siteId, input.startDate, input.endDate);
        return {
          available: bookings.length === 0,
          bookings: bookings.map(b => ({
            id: b.id,
            startDate: b.startDate,
            endDate: b.endDate,
            status: b.status,
          })),
        };
      }),

    getApprovedCategories: publicProcedure
      .input(z.object({ siteId: z.number() }))
      .query(async ({ input }) => {
        const { getApprovedCategoriesForSite } = await import("./usageCategoriesDb");
        return await getApprovedCategoriesForSite(input.siteId);
      }),

    setApprovedCategories: protectedProcedure
      .input(z.object({
        siteId: z.number(),
        categoryIds: z.array(z.number()),
      }))
      .mutation(async ({ input, ctx }) => {
        // Only owners and mega admins can manage site categories
        const allowedRoles = ['owner_super_admin', 'owner_state_admin', 'owner_regional_admin', 'owner_centre_manager', 'mega_admin', 'mega_state_admin'];
        if (!allowedRoles.includes(ctx.user.role)) {
          throw new TRPCError({ code: 'FORBIDDEN', message: 'Only owners and administrators can manage site categories' });
        }

        const { setApprovedCategoriesForSite } = await import("./usageCategoriesDb");
        await setApprovedCategoriesForSite(input.siteId, input.categoryIds);
        return { success: true };
      }),
  }),

  // Bookings
  bookings: router({
    create: protectedProcedure
      .input(z.object({
        siteId: z.number(),
        usageTypeId: z.number().optional(), // legacy field
        customUsage: z.string().optional(), // legacy field
        usageCategoryId: z.number().optional(),
        additionalCategoryText: z.string().optional(),
        startDate: z.date(),
        endDate: z.date(),
        tablesRequested: z.number().optional().default(0),
        chairsRequested: z.number().optional().default(0),
      }))
      .mutation(async ({ input, ctx }) => {
        // Check availability
        const existingBookings = await db.getBookingsBySiteId(input.siteId, input.startDate, input.endDate);
        if (existingBookings.length > 0) {
          throw new TRPCError({ code: "CONFLICT", message: "Site is already booked for this period" });
        }

        // Get site details for pricing
        const site = await db.getSiteById(input.siteId);
        if (!site) throw new TRPCError({ code: "NOT_FOUND", message: "Site not found" });

        // Calculate booking duration and price with weekend rate support
        const { totalAmount, weekdayCount, weekendCount } = await import("./bookingCalculation").then(m => 
          m.calculateBookingCost(site, input.startDate, input.endDate)
        );

        // Get GST rate
        const gstValue = await getConfigValue("gst_percentage");
        const gstRate = gstValue ? Number(gstValue) / 100 : 0.1;
        const gstAmount = totalAmount * gstRate;

        // Get centre and owner info for commission
        const centre = await db.getShoppingCentreById(site.centreId);
        if (!centre) throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
        
        const owner = await db.getOwnerById(centre.ownerId);
        if (!owner) throw new TRPCError({ code: "NOT_FOUND", message: "Owner not found" });

        const platformFee = totalAmount * (Number(owner.commissionPercentage) / 100);
        const ownerAmount = totalAmount - platformFee;

        // Generate booking number with abbreviated centre code: {CODE}-{YYYYMMDD}-{SEQ}
        // Example: CAMP-20260601-001 (Campbelltown Mall)
        const { getCentreCodeForBooking } = await import('./centreCodeHelper');
        const centreCode = getCentreCodeForBooking(centre);
        const dateStr = new Date(input.startDate).toISOString().split('T')[0].replace(/-/g, ''); // YYYYMMDD
        const randomSeq = Math.floor(Math.random() * 1000).toString().padStart(3, '0'); // 001-999
        const bookingNumber = `${centreCode}-${dateStr}-${randomSeq}`;

        // Check equipment availability if requested
        let equipmentWarning: string | undefined;
        if ((input.tablesRequested || 0) > 0 || (input.chairsRequested || 0) > 0) {
          const { checkEquipmentAvailability } = await import("./equipmentAvailability");
          const equipmentCheck = await checkEquipmentAvailability(
            site.centreId,
            input.startDate,
            input.endDate,
            input.tablesRequested || 0,
            input.chairsRequested || 0
          );
          
          if (!equipmentCheck.available) {
            equipmentWarning = equipmentCheck.message;
          }
        }

        // Determine if approval is needed based on usage categories
        let requiresApproval = false;
        
        if (input.usageCategoryId) {
          // Check if additional text was provided (triggers manual approval)
          if (input.additionalCategoryText && input.additionalCategoryText.trim().length > 0) {
            requiresApproval = true;
          } else {
            // Check if category is approved for this site
            const { isCategoryApprovedForSite, getApprovedCategoriesForSite } = await import("./usageCategoriesDb");
            const approvedCategories = await getApprovedCategoriesForSite(input.siteId);
            
            // If no approvals exist (empty), treat as all approved (default behavior - skip duplicate check)
            if (approvedCategories.length === 0) {
              // Default all approved - no additional checks needed
              requiresApproval = false;
            } else {
              // Approvals exist - check if this specific category is approved
              const isApproved = await isCategoryApprovedForSite(input.siteId, input.usageCategoryId);
              
              if (!isApproved) {
                requiresApproval = true;
              } else {
                // Category is explicitly approved - check for overlapping bookings from OTHER customers
                // This ensures category exclusivity: only one vendor per category at a time
              const { getDb } = await import("./db");
              const { bookings, sites: sitesTable } = await import("../drizzle/schema");
              const { eq, and, ne, or, lte, gte } = await import("drizzle-orm");
              const dbInstance = await getDb();
              if (dbInstance) {
                // Get the centre ID for the current site
                const currentSite = await dbInstance.select().from(sitesTable)
                  .where(eq(sitesTable.id, input.siteId))
                  .limit(1);
                
                if (currentSite.length > 0) {
                  const centreId = currentSite[0].centreId;
                  
                  // Find overlapping bookings from DIFFERENT customers with same category at same centre
                  // Date overlap logic: (newStart <= existingEnd) AND (newEnd >= existingStart)
                  const overlappingBookings = await dbInstance.select({
                    bookingId: bookings.id,
                    customerId: bookings.customerId,
                    startDate: bookings.startDate,
                    endDate: bookings.endDate,
                  })
                    .from(bookings)
                    .innerJoin(sitesTable, eq(bookings.siteId, sitesTable.id))
                    .where(and(
                      ne(bookings.customerId, ctx.user.id), // DIFFERENT customer
                      eq(bookings.usageCategoryId, input.usageCategoryId), // SAME category
                      eq(sitesTable.centreId, centreId), // SAME centre
                      or(
                        eq(bookings.status, 'pending'),
                        eq(bookings.status, 'confirmed')
                      ), // Only active bookings
                      // Date overlap check
                      lte(bookings.startDate, input.endDate),
                      gte(bookings.endDate, input.startDate)
                    ));
                  
                  if (overlappingBookings.length > 0) {
                    requiresApproval = true;
                  }
                }
              }
              }
            }
          }
        } else if (input.customUsage) {
          // Legacy: custom usage always requires approval
          requiresApproval = true;
        } else if (input.usageTypeId) {
          // Legacy: check old usage types
          const usageType = await db.getUsageTypes();
          const selectedUsage = usageType.find(u => u.id === input.usageTypeId);
          if (selectedUsage?.requiresApproval) {
            requiresApproval = true;
          }
        }

        // Check if user can pay by invoice
        const currentUser = await db.getUserByOpenId(ctx.user.openId);
        const canPayByInvoice = currentUser?.canPayByInvoice || false;

        // Check insurance expiry date
        const customerProfile = await db.getCustomerProfileByUserId(ctx.user.id);
        let insuranceExpired = false;
        
        if (customerProfile?.insuranceExpiry) {
          const insuranceExpiryDate = new Date(customerProfile.insuranceExpiry);
          const bookingEndDate = new Date(input.endDate);
          
          // If insurance expires before booking end date, flag for manual approval
          if (insuranceExpiryDate < bookingEndDate) {
            requiresApproval = true;
            insuranceExpired = true;
          }
        }

        // Calculate payment due date for invoice bookings (7 days from booking creation)
        const paymentDueDate = canPayByInvoice ? new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) : null;

        // Create booking
        const result = await db.createBooking({
          bookingNumber,
          siteId: input.siteId,
          customerId: ctx.user.id,
          usageTypeId: input.usageTypeId,
          customUsage: input.customUsage,
          usageCategoryId: input.usageCategoryId,
          additionalCategoryText: input.additionalCategoryText,
          startDate: input.startDate,
          endDate: input.endDate,
          totalAmount: totalAmount.toFixed(2),
          gstAmount: gstAmount.toFixed(2),
          gstPercentage: (gstRate * 100).toFixed(2), // Store GST percentage at time of booking
          ownerAmount: ownerAmount.toFixed(2),
          platformFee: platformFee.toFixed(2),
          paymentMethod: canPayByInvoice ? "invoice" : "stripe",
          paymentDueDate: paymentDueDate,
          status: requiresApproval ? "pending" : (site.instantBooking ? "confirmed" : "pending"),
          requiresApproval,
          tablesRequested: input.tablesRequested || 0,
          chairsRequested: input.chairsRequested || 0,
        });

        return {
          bookingId: Number(result[0].insertId),
          bookingNumber,
          totalAmount,
          requiresApproval,
          insuranceExpired,
          canPayByInvoice,
          paymentMethod: canPayByInvoice ? "invoice" as const : "stripe" as const,
          equipmentWarning,
          costBreakdown: {
            weekdayCount,
            weekendCount,
            weekdayRate: Number(site.pricePerDay),
            weekendRate: site.weekendPricePerDay ? Number(site.weekendPricePerDay) : Number(site.pricePerDay),
            subtotal: totalAmount,
            gstAmount,
            total: totalAmount + gstAmount,
          },
        };
      }),

    calculatePreview: publicProcedure
      .input(z.object({
        siteId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
      }))
      .query(async ({ input }) => {
        // Get site details for pricing
        const site = await db.getSiteById(input.siteId);
        if (!site) throw new TRPCError({ code: "NOT_FOUND", message: "Site not found" });

        // Calculate booking cost with seasonal rates
        const { totalAmount, weekdayCount, weekendCount, seasonalDays } = await import("./bookingCalculation").then(m => 
          m.calculateBookingCost(site, input.startDate, input.endDate)
        );

        // Get GST rate
        const gstValue = await getConfigValue("gst_percentage");
        const gstRate = gstValue ? Number(gstValue) / 100 : 0.1;
        const gstAmount = totalAmount * gstRate;

        return {
          weekdayCount,
          weekendCount,
          weekdayRate: Number(site.pricePerDay),
          weekendRate: site.weekendPricePerDay ? Number(site.weekendPricePerDay) : Number(site.pricePerDay),
          subtotal: totalAmount,
          gstAmount,
          gstPercentage: gstRate * 100, // Return current GST percentage
          total: totalAmount + gstAmount,
          seasonalDays: seasonalDays || [],
        };
      }),

    myBookings: protectedProcedure.query(async ({ ctx }) => {
      return await db.getBookingsByCustomerId(ctx.user.id);
    }),

    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input, ctx }) => {
        const booking = await db.getBookingById(input.id);
        if (!booking) throw new TRPCError({ code: "NOT_FOUND", message: "Booking not found" });
        
        // Check if user owns this booking
        if (booking.customerId !== ctx.user.id) {
          throw new TRPCError({ code: "FORBIDDEN", message: "Not authorized" });
        }
        
        return booking;
      }),

    list: adminProcedure
      .input(z.object({
        status: z.enum(["pending", "confirmed", "cancelled", "completed", "unpaid"]).optional(),
      }))
      .query(async ({ input }) => {
        // Handle "unpaid" status specially - it's not a database status
        if (input.status === "unpaid") {
          return await db.getUnpaidInvoiceBookings();
        }
        return await db.getBookingsByStatus(input.status);
      }),

    approve: adminProcedure
      .input(z.object({ bookingId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const booking = await db.getBookingById(input.bookingId);
        if (!booking) throw new TRPCError({ code: "NOT_FOUND", message: "Booking not found" });
        
        if (booking.status !== "pending") {
          throw new TRPCError({ code: "BAD_REQUEST", message: "Only pending bookings can be approved" });
        }

        await db.approveBooking(input.bookingId, ctx.user.id);
        
        // Send confirmation email to customer
        const site = await db.getSiteById(booking.siteId);
        const centre = site ? await db.getShoppingCentreById(site.centreId) : null;
        const customer = await db.getUserById(booking.customerId);
        
        if (customer && site && centre) {
          await sendBookingConfirmationEmail({
            bookingNumber: booking.bookingNumber,
            customerName: customer.name || "Customer",
            customerEmail: customer.email || "",
            centreName: centre.name,
            siteNumber: site.siteNumber,
            startDate: booking.startDate,
            endDate: booking.endDate,
            totalAmount: booking.totalAmount,
          });
        }
        
        return { success: true };
      }),

    reject: adminProcedure
      .input(z.object({ 
        bookingId: z.number(),
        reason: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        const booking = await db.getBookingById(input.bookingId);
        if (!booking) throw new TRPCError({ code: "NOT_FOUND", message: "Booking not found" });
        
        if (booking.status !== "pending") {
          throw new TRPCError({ code: "BAD_REQUEST", message: "Only pending bookings can be rejected" });
        }

        await db.rejectBooking(input.bookingId, input.reason);
        
        // Send rejection email to customer with reason
        const site = await db.getSiteById(booking.siteId);
        const centre = site ? await db.getShoppingCentreById(site.centreId) : null;
        const customer = await db.getUserById(booking.customerId);
        
        if (customer && site && centre) {
          await sendBookingRejectionEmail(
            {
              bookingNumber: booking.bookingNumber,
              customerName: customer.name || "Customer",
              customerEmail: customer.email || "",
              centreName: centre.name,
              siteNumber: site.siteNumber,
              startDate: booking.startDate,
              endDate: booking.endDate,
              totalAmount: booking.totalAmount,
            },
            input.reason || "No reason provided"
          );
        }
        
        return { success: true };
      }),

    getPendingApprovals: adminProcedure
      .input(z.object({
        status: z.enum(["pending", "confirmed", "rejected", "all"]).default("pending"),
      }))
      .query(async ({ input }) => {
        const { getDb } = await import("./db");
        const { bookings, sites, shoppingCentres, users, usageCategories } = await import("../drizzle/schema");
        const { eq, and, inArray } = await import("drizzle-orm");
        
        const db = await getDb();
        if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database connection failed" });

        // Build where clause based on status filter
        const whereClause = input.status === "all" 
          ? undefined 
          : eq(bookings.status, input.status);

        // Fetch bookings with joined data
        const bookingsList = await db
          .select({
            id: bookings.id,
            bookingNumber: bookings.bookingNumber,
            status: bookings.status,
            startDate: bookings.startDate,
            endDate: bookings.endDate,
            totalAmount: bookings.totalAmount,
            ownerAmount: bookings.ownerAmount,
            requiresApproval: bookings.requiresApproval,
            additionalCategoryText: bookings.additionalCategoryText,
            rejectionReason: bookings.rejectionReason,
            createdAt: bookings.createdAt,
            // Customer info
            customerId: users.id,
            customerName: users.name,
            customerEmail: users.email,
            // Site info
            siteId: sites.id,
            siteNumber: sites.siteNumber,
            // Centre info
            centreId: shoppingCentres.id,
            centreName: shoppingCentres.name,
            // Category info
            categoryId: usageCategories.id,
            categoryName: usageCategories.name,
          })
          .from(bookings)
          .innerJoin(users, eq(bookings.customerId, users.id))
          .innerJoin(sites, eq(bookings.siteId, sites.id))
          .innerJoin(shoppingCentres, eq(sites.centreId, shoppingCentres.id))
          .leftJoin(usageCategories, eq(bookings.usageCategoryId, usageCategories.id))
          .where(whereClause)
          .orderBy(bookings.createdAt);

        return bookingsList;
      }),
  }),

  // Customer Profile
  profile: router({
    get: protectedProcedure.query(async ({ ctx }) => {
      return await db.getCustomerProfileByUserId(ctx.user.id);
    }),

    update: protectedProcedure
      .input(z.object({
        firstName: z.string().optional(),
        lastName: z.string().optional(),
        phone: z.string().optional(),
        companyName: z.string().optional(),
        website: z.string().optional(),
        abn: z.string().optional(),
        streetAddress: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        postcode: z.string().optional(),
        productCategory: z.string().optional(),
        insuranceCompany: z.string().optional(),
        insurancePolicyNo: z.string().optional(),
        insuranceAmount: z.string().optional(),
        insuranceExpiry: z.date().optional(),
        insuranceDocumentUrl: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const existing = await db.getCustomerProfileByUserId(ctx.user.id);
        
        if (existing) {
          await db.updateCustomerProfile(ctx.user.id, input);
        } else {
          await db.createCustomerProfile({
            userId: ctx.user.id,
            ...input,
          });
        }
        
        return { success: true };
      }),

    uploadInsurance: protectedProcedure
      .input(z.object({
        fileData: z.string(), // base64 encoded file
        fileName: z.string(),
        mimeType: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        const { storagePut } = await import('./storage');
        
        // Extract base64 data from data URL (remove "data:image/png;base64," prefix)
        const base64Data = input.fileData.includes(',') 
          ? input.fileData.split(',')[1] 
          : input.fileData;
        
        // Decode base64 and upload to S3
        const buffer = Buffer.from(base64Data, 'base64');
        const fileKey = `insurance/${ctx.user.id}/${Date.now()}-${input.fileName}`;
        
        const { url } = await storagePut(fileKey, buffer, input.mimeType);
        
        return { url };
      }),

    scanInsurance: protectedProcedure
      .input(z.object({
        documentUrl: z.string(),
      }))
      .mutation(async ({ input }) => {
        const { scanInsuranceDocument, validateInsurance } = await import('./insuranceScanner');
        
        const scanResult = await scanInsuranceDocument(input.documentUrl);
        const validation = validateInsurance(scanResult);
        
        // Return scan result with validation warnings, but don't block
        return {
          ...scanResult,
          warnings: validation.valid ? [] : validation.errors,
        };
      }),
  }),

  // Usage Types
  usageTypes: router({
    list: publicProcedure.query(async () => {
      return await db.getUsageTypes();
    }),
  }),

  // Search with date
  search: router({
    // Smart search with site-level support
    smart: publicProcedure
      .input(z.object({ query: z.string(), date: z.date() }))
      .query(async ({ input, ctx }) => {
        // Parse query to extract requirements
        const { parseSearchQuery, siteMatchesRequirements } = await import("../shared/queryParser");
        const parsedQuery = parseSearchQuery(input.query);
        console.log('[search] input.query:', input.query, 'parsedQuery:', parsedQuery);
        
        // Try site-level search first using the extracted centre name and category
        const searchQuery = parsedQuery.centreName || input.query;
        console.log('[search] searchQuery:', searchQuery, 'productCategory:', parsedQuery.productCategory);
        const siteResults = await db.searchSitesWithCategory(searchQuery, parsedQuery.productCategory);
        console.log('[search] siteResults count:', siteResults.length);
        
        // If we found specific sites, use those
        if (siteResults.length > 0 && siteResults.length <= 10) {
          const centreIds = Array.from(new Set(siteResults.map(r => r.site.centreId)));
          const centres = await Promise.all(
            centreIds.map(async (centreId) => {
              const centre = siteResults.find(r => r.site.centreId === centreId)?.centre;
              if (!centre) return null;
              return centre;
            })
          );
          
          // Use these centres for the search
          const validCentres = centres.filter((c): c is NonNullable<typeof c> => c !== null);
          if (validCentres.length > 0) {
            input.query = validCentres[0]!.name; // Use first centre name
          }
        }
        
        // Continue with regular search logic using the parsed centre name
        const centres = await db.searchShoppingCentres(searchQuery);
        
        if (centres.length === 0) {
          // Get search suggestions when no results found
          const { getSearchSuggestions } = await import("./searchSuggestions");
          const suggestions = await getSearchSuggestions(searchQuery, 5);
          
          // Log failed search
          const { logSearch } = await import("./searchAnalyticsDb");
          await logSearch({
            userId: ctx.user?.id,
            query: input.query,
            centreName: parsedQuery.centreName,
            minSizeM2: parsedQuery.minSizeM2,
            productCategory: parsedQuery.productCategory,
            resultsCount: 0,
            suggestionsShown: suggestions.length,
            searchDate: input.date,
          });
          
          return { 
            centres: [], 
            sites: [], 
            availability: [], 
            matchedSiteIds: [],
            suggestions // Add suggestions to response
          };
        }

        const startOfWeek = new Date(input.date);
        startOfWeek.setHours(0, 0, 0, 0);
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(endOfWeek.getDate() + 6);
        
        const startOfNextWeek = new Date(endOfWeek);
        startOfNextWeek.setDate(startOfNextWeek.getDate() + 1);
        const endOfNextWeek = new Date(startOfNextWeek);
        endOfNextWeek.setDate(endOfNextWeek.getDate() + 6);

        const allSites: any[] = [];
        const availability: any[] = [];
        const matchedSiteIds: number[] = siteResults.map(r => r.site.id);
        
        // Track if any sites match the size requirement
        let hasMatchingSites = false;
        const hasRequirements = parsedQuery.minSizeM2 !== undefined || parsedQuery.minTables !== undefined || parsedQuery.productCategory !== undefined;
        
        // OPTIMIZED: Batch fetch all data in minimal queries
        const { getSearchDataOptimized } = await import("./dbOptimized");
        const centreIds = centres.map(c => c.id);
        
        let {
          sitesByCentre,
          week1BookingsBySite,
          week2BookingsBySite,
          categoriesBySite,
        } = await getSearchDataOptimized(
          centreIds,
          startOfWeek,
          endOfWeek,
          startOfNextWeek,
          endOfNextWeek
        );
        
        // Override sitesByCentre if we have category-filtered sites from searchSitesWithCategory
        if (parsedQuery.productCategory && siteResults.length > 0) {
          const tempSitesByCentre = new Map();
          for (const result of siteResults) {
            const centreId = result.site.centreId;
            if (!tempSitesByCentre.has(centreId)) {
              tempSitesByCentre.set(centreId, []);
            }
            tempSitesByCentre.get(centreId)!.push(result.site);
          }
          sitesByCentre = tempSitesByCentre;
        }
        
        // First pass: check if any sites match the requirements and find closest match
        let closestMatch: { sizeM2: number; widthM: number; lengthM: number; difference: number } | null = null;
        const requestedSizeM2 = parsedQuery.minSizeM2;
        
        for (const centre of centres) {
          const sites = sitesByCentre.get(centre.id) || [];
          
          // Check which sites match the requirements
          const sitesWithMatch = sites.map((site: any) => ({
            site,
            matchesRequirements: siteMatchesRequirements(site, parsedQuery),
            sizeMatch: requestedSizeM2 ? (site.sizeM2 === requestedSizeM2 ? 'perfect' : site.sizeM2 > requestedSizeM2 ? 'larger' : 'smaller') : null
          }));
          
          // Check if any sites match
          if (sitesWithMatch.some((s: any) => s.matchesRequirements)) {
            hasMatchingSites = true;
          }
          
          // Track closest match for size suggestions
          if (requestedSizeM2 && !hasMatchingSites) {
            for (const { site } of sitesWithMatch) {
              if (site.sizeM2 && site.sizeM2 >= requestedSizeM2) {
                const diff = Math.abs(site.sizeM2 - requestedSizeM2);
                if (!closestMatch || diff < closestMatch.difference) {
                  closestMatch = {
                    sizeM2: site.sizeM2,
                    widthM: site.widthM,
                    lengthM: site.lengthM,
                    difference: diff
                  };
                }
              }
            }
          }
        }
        
        // Second pass: collect sites based on whether matches were found
        const siteCategories: Record<number, any[]> = {};
        
        for (const centre of centres) {
          const sites = sitesByCentre.get(centre.id) || [];
          
          // Check which sites match the requirements
          const sitesWithMatch = sites.map((site: any) => ({
            site,
            matchesRequirements: siteMatchesRequirements(site, parsedQuery),
            sizeMatch: requestedSizeM2 ? (site.sizeM2 === requestedSizeM2 ? 'perfect' : site.sizeM2 > requestedSizeM2 ? 'larger' : 'smaller') : null
          }));
          
          // Determine which sites to include based on requirements
          let sitesToInclude = sitesWithMatch;
          if (hasRequirements && hasMatchingSites) {
            // If size/table requirements specified and matches found, only include matching sites
            sitesToInclude = sitesWithMatch.filter((s: any) => s.matchesRequirements);
          }
          
          const sitesWithData = sitesToInclude.map(({ site, sizeMatch }: any) => ({ ...site, centreName: centre.name, sizeMatch }));
          allSites.push(...sitesWithData);
          
          for (const { site } of sitesToInclude as any[]) {
            // Use pre-fetched data instead of individual queries
            const week1Bookings = week1BookingsBySite.get(site.id) || [];
            const week2Bookings = week2BookingsBySite.get(site.id) || [];
            const approvedCategories = categoriesBySite.get(site.id) || [];
            
            siteCategories[site.id] = approvedCategories;
            
            availability.push({
              siteId: site.id,
              siteNumber: site.siteNumber,
              centreName: centre.name,
              week1Available: week1Bookings.length === 0,
              week2Available: week2Bookings.length === 0,
              week1Bookings,
              week2Bookings,
            });
          }
        }
        
        // Return flag indicating if size requirement was met
        const sizeNotAvailable = hasRequirements && !hasMatchingSites;
        
        // Log successful search
        const { logSearch } = await import("./searchAnalyticsDb");
        await logSearch({
          userId: ctx.user?.id,
          query: input.query,
          centreName: parsedQuery.centreName,
          minSizeM2: parsedQuery.minSizeM2,
          productCategory: parsedQuery.productCategory,
          resultsCount: allSites.length,
          suggestionsShown: 0,
          searchDate: input.date,
        });
        
        return { centres, sites: allSites, availability, matchedSiteIds, sizeNotAvailable, closestMatch, siteCategories };
      }),
    byNameAndDate: publicProcedure
      .input(z.object({
        centreName: z.string(),
        date: z.date(),
      }))
      .query(async ({ input }) => {
        // Search for centres matching the name
        const centres = await db.searchShoppingCentres(input.centreName);
        
        if (centres.length === 0) {
          return { centres: [], sites: [], availability: [] };
        }

        // Get the requested week start and end
        const startOfWeek = new Date(input.date);
        startOfWeek.setHours(0, 0, 0, 0);
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(endOfWeek.getDate() + 6);
        
        // Get the following week
        const startOfNextWeek = new Date(endOfWeek);
        startOfNextWeek.setDate(startOfNextWeek.getDate() + 1);
        const endOfNextWeek = new Date(startOfNextWeek);
        endOfNextWeek.setDate(endOfNextWeek.getDate() + 6);

        // Get all sites for these centres
        const allSites = [];
        const availability = [];
        
        for (const centre of centres) {
          const sites = await db.getSitesByCentreId(centre.id);
          allSites.push(...sites.map(s => ({ ...s, centreName: centre.name })));
          
          // Check availability for each site
          for (const site of sites) {
            const week1Bookings = await db.getBookingsBySiteId(site.id, startOfWeek, endOfWeek);
            const week2Bookings = await db.getBookingsBySiteId(site.id, startOfNextWeek, endOfNextWeek);
            
            availability.push({
              siteId: site.id,
              week1Available: week1Bookings.length === 0,
              week2Available: week2Bookings.length === 0,
              week1Bookings: week1Bookings.map(b => ({ startDate: b.startDate, endDate: b.endDate })),
              week2Bookings: week2Bookings.map(b => ({ startDate: b.startDate, endDate: b.endDate })),
            });
          }
        }

        return {
          centres,
          sites: allSites,
          availability,
          requestedWeek: { start: startOfWeek, end: endOfWeek },
          followingWeek: { start: startOfNextWeek, end: endOfNextWeek },
        };
      }),
  }),

  // Admin endpoints
  admin: router({
    getStats: adminProcedure.query(async () => {
      const centres = await db.getShoppingCentres();
      const sites = await db.getAllSites();
      const bookings = await db.getAllBookings();
      const users = await db.getAllUsers();
      
      const activeBookings = bookings.filter(
        (b) => b.status === 'confirmed' || b.status === 'pending'
      );
      
      const totalRevenue = bookings
        .filter((b: any) => b.status === 'confirmed' || b.status === 'completed')
        .reduce((sum: number, b: any) => sum + parseFloat(b.totalAmount), 0);
      
      const now = new Date();
      const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
      const monthlyRevenue = bookings
        .filter(
          (b: any) =>
            (b.status === 'confirmed' || b.status === 'completed') &&
            new Date(b.createdAt) >= monthStart
        )
        .reduce((sum: number, b: any) => sum + parseFloat(b.totalAmount), 0);
      
      const recentBookings = bookings
        .sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
        .slice(0, 5)
        .map((b: any) => ({
          id: b.id,
          siteName: `Site ${b.siteId}`,
          startDate: b.startDate,
          endDate: b.endDate,
          totalPrice: parseFloat(b.totalAmount),
          status: b.status,
        }));
      
      return {
        totalCentres: centres.length,
        totalSites: sites.length,
        activeBookings: activeBookings.length,
        totalRevenue,
        monthlyRevenue,
        totalUsers: users.length,
        recentBookings,
      };
    }),

    // Shopping Centre Management
    createCentre: adminProcedure
      .input(z.object({
        name: z.string(),
        address: z.string().optional(),
        suburb: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        postcode: z.string().optional(),
        description: z.string().optional(),
      }))
      .mutation(async ({ input }) => {
        return await db.createShoppingCentre({
          ...input,
          ownerId: 1, // Default owner, should be dynamic based on user
        });
      }),

    updateCentre: adminProcedure
      .input(z.object({
        id: z.number(),
        name: z.string(),
        address: z.string().optional(),
        suburb: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        postcode: z.string().optional(),
        description: z.string().optional(),
      }))
      .mutation(async ({ input }) => {
        return await db.updateShoppingCentre(input.id, input);
      }),

    deleteCentre: adminProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        return await db.deleteShoppingCentre(input.id);
      }),

    // Site Management
    createSite: adminProcedure
      .input(z.object({
        centreId: z.number(),
        siteNumber: z.string(),
        description: z.string().optional(),
        size: z.string().optional(),
        maxTables: z.number().optional(),
        powerAvailable: z.string().optional(),
        restrictions: z.string().optional(),
        dailyRate: z.string(),
        weeklyRate: z.string(),
        instantBooking: z.boolean().optional(),
      }))
      .mutation(async ({ input }) => {
        return await db.createSite(input);
      }),

    updateSite: adminProcedure
      .input(z.object({
        id: z.number(),
        siteNumber: z.string().optional(),
        description: z.string().optional(),
        size: z.string().optional(),
        maxTables: z.number().optional(),
        powerAvailable: z.string().optional(),
        restrictions: z.string().optional(),
        dailyRate: z.string().optional(),
        weeklyRate: z.string().optional(),
        weekendRate: z.string().optional(),
        instantBooking: z.boolean().optional(),
        imageUrl1: z.string().nullish(),
        imageUrl2: z.string().nullish(),
        imageUrl3: z.string().nullish(),
        imageUrl4: z.string().nullish(),
      }))
      .mutation(async ({ input }) => {
        const { id, dailyRate, weeklyRate, weekendRate, ...rest } = input;
        const data: any = { ...rest };
        
        // Map frontend field names to database column names
        if (dailyRate !== undefined) data.pricePerDay = dailyRate;
        if (weeklyRate !== undefined) data.pricePerWeek = weeklyRate;
        if (weekendRate !== undefined) data.weekendPricePerDay = weekendRate;
        
        return await db.updateSite(id, data);
      }),

    getSystemConfig: protectedProcedure
      .query(async () => {
        return await getSystemConfigDb();
      }),

    updateSystemConfig: adminProcedure
      .input(z.object({
        imageQuality: z.number().min(50).max(100),
        imageMaxWidth: z.number().min(800).max(2400),
        imageMaxHeight: z.number().min(600).max(1600),
      }))
      .mutation(async ({ input }) => {
        await updateSystemConfigDb(input);
        return { success: true };
      }),

    // Image Analytics
    trackImageView: publicProcedure
      .input(z.object({
        siteId: z.number(),
        imageSlot: z.number().min(1).max(4),
      }))
      .mutation(async ({ input }) => {
        await trackImageView(input.siteId, input.imageSlot);
        return { success: true };
      }),

    trackImageClick: publicProcedure
      .input(z.object({
        siteId: z.number(),
        imageSlot: z.number().min(1).max(4),
      }))
      .mutation(async ({ input }) => {
        await trackImageClick(input.siteId, input.imageSlot);
        return { success: true };
      }),

    getTopPerformingImages: protectedProcedure
      .input(z.object({
        limit: z.number().optional().default(10),
      }))
      .query(async ({ input }) => {
        return await getTopPerformingImages(input.limit);
      }),

    getImageAnalyticsBySite: protectedProcedure
      .input(z.object({
        siteId: z.number(),
      }))
      .query(async ({ input }) => {
        return await getImageAnalyticsBySite(input.siteId);
      }),

    uploadSiteImage: adminProcedure
      .input(z.object({
        siteId: z.number(),
        imageSlot: z.number().min(1).max(4),
        base64Image: z.string(),
      }))
      .mutation(async ({ input }) => {
        const { processSiteImage } = await import('./imageProcessing');
        const { url } = await processSiteImage(
          input.base64Image,
          input.siteId,
          input.imageSlot
        );
        
        // Update the site with the new image URL
        await db.updateSite(input.siteId, {
          [`imageUrl${input.imageSlot}`]: url,
        } as any);
        
        return { url };
      }),

    deleteSite: adminProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        return await db.deleteSite(input.id);
      }),

    // Map Management
    uploadCentreMap: adminProcedure
      .input(z.object({
        centreId: z.number(),
        imageData: z.string(), // base64 encoded image
        fileName: z.string(),
      }))
      .mutation(async ({ input }) => {
        return await db.uploadCentreMap(input.centreId, input.imageData, input.fileName);
      }),

    saveSiteMarkers: adminProcedure
      .input(z.object({
        centreId: z.number(),
        markers: z.array(z.object({
          siteId: z.number(),
          x: z.number().min(0).max(100),
          y: z.number().min(0).max(100),
        })),
      }))
      .mutation(async ({ input }) => {
        return await db.saveSiteMarkers(input.markers);
      }),

    resetSiteMarker: adminProcedure
      .input(z.object({
        siteId: z.number(),
      }))
      .mutation(async ({ input }) => {
        return await db.resetSiteMarker(input.siteId);
      }),

    // Floor Level Management
    getFloorLevels: adminProcedure
      .input(z.object({ centreId: z.number() }))
      .query(async ({ input }) => {
        return await db.getFloorLevelsByCentre(input.centreId);
      }),

    createFloorLevel: adminProcedure
      .input(z.object({
        centreId: z.number(),
        levelName: z.string(),
        levelNumber: z.number(),
        displayOrder: z.number(),
      }))
      .mutation(async ({ input }) => {
        return await db.createFloorLevel(input);
      }),

    deleteFloorLevel: adminProcedure
      .input(z.object({ floorLevelId: z.number() }))
      .mutation(async ({ input }) => {
        return await db.deleteFloorLevel(input.floorLevelId);
      }),

    uploadFloorLevelMap: adminProcedure
      .input(z.object({
        floorLevelId: z.number(),
        imageData: z.string(),
        fileName: z.string(),
      }))
      .mutation(async ({ input }) => {
        return await db.uploadFloorLevelMap(input.floorLevelId, input.imageData, input.fileName);
      }),

    getSitesByFloorLevel: adminProcedure
      .input(z.object({ floorLevelId: z.number() }))
      .query(async ({ input }) => {
        return await db.getSitesByFloorLevel(input.floorLevelId);
      }),

    updateSiteFloorAssignment: adminProcedure
      .input(z.object({
        assignments: z.array(z.object({
          siteId: z.number(),
          floorLevelId: z.number().nullable()
        }))
      }))
      .mutation(async ({ input }) => {
        return await db.updateSiteFloorAssignments(input.assignments);
      }),

    // Seasonal Pricing Management
    getSeasonalRatesBySite: adminProcedure
      .input(z.object({ siteId: z.number() }))
      .query(async ({ input }) => {
        return await getSeasonalRatesBySiteId(input.siteId);
      }),

    createSeasonalRate: adminProcedure
      .input(z.object({
        siteId: z.number(),
        name: z.string(),
        startDate: z.string(),
        endDate: z.string(),
        weekdayRate: z.number().optional(),
        weekendRate: z.number().optional(),
        weeklyRate: z.number().optional(),
      }))
      .mutation(async ({ input }) => {
        return await createSeasonalRate(input);
      }),

    updateSeasonalRate: adminProcedure
      .input(z.object({
        id: z.number(),
        name: z.string().optional(),
        startDate: z.string().optional(),
        endDate: z.string().optional(),
        weekdayRate: z.number().optional(),
        weekendRate: z.number().optional(),
        weeklyRate: z.number().optional(),
      }))
      .mutation(async ({ input }) => {
        const { id, ...data } = input;
        return await updateSeasonalRate(id, data);
      }),

    deleteSeasonalRate: adminProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        return await deleteSeasonalRate(input.id);
      }),

    getOwners: adminProcedure
      .query(async () => {
        return await db.getOwners();
      }),

    getAllCentres: adminProcedure
      .query(async () => {
        const centres = await db.getShoppingCentres();
        // Get sites for each centre to calculate max tables needed
        const centresWithSites = await Promise.all(
          centres.map(async (centre) => {
            const sites = await db.getSitesByCentreId(centre.id);
            return { ...centre, sites };
          })
        );
        return centresWithSites;
      }),

    updateCentreEquipment: adminProcedure
      .input(z.object({
        centreId: z.number(),
        totalTablesAvailable: z.number().min(0),
        totalChairsAvailable: z.number().min(0),
      }))
      .mutation(async ({ input }) => {
        return await db.updateShoppingCentre(input.centreId, {
          totalTablesAvailable: input.totalTablesAvailable,
          totalChairsAvailable: input.totalChairsAvailable,
        });
      }),

    // Booking Approval Management
    getPendingApprovals: adminProcedure
      .query(async () => {
        const pendingBookings = await db.getBookingsByStatus('pending');
        
        // Get additional details for each booking
        const bookingsWithDetails = await Promise.all(
          pendingBookings
            .filter(b => b.requiresApproval)
            .map(async (booking) => {
              const site = await db.getSiteById(booking.siteId);
              const centre = site ? await db.getShoppingCentreById(site.centreId) : null;
              const customer = await db.getUserById(booking.customerId);
              const usageType = booking.usageTypeId ? await db.getUsageTypeById(booking.usageTypeId) : null;
              
              // Determine specific approval reason
              const customerProfile = await db.getCustomerProfileByUserId(booking.customerId);
              let approvalReason = 'Manual approval required';
              let insuranceExpired = false;
              const reasons: string[] = [];
              
              // Check insurance expiry
              if (customerProfile?.insuranceExpiry) {
                const insuranceExpiryDate = new Date(customerProfile.insuranceExpiry);
                const bookingEndDate = new Date(booking.endDate);
                
                if (insuranceExpiryDate < bookingEndDate) {
                  reasons.push('Insurance expired before booking end date');
                  insuranceExpired = true;
                }
              }
              
              // Check insurance coverage amount
              if (customerProfile?.insuranceAmount) {
                const coverageAmount = parseFloat(customerProfile.insuranceAmount);
                const requiredAmount = 20000000; // $20M minimum
                
                if (coverageAmount < requiredAmount) {
                  reasons.push(`Insufficient insurance coverage ($${(coverageAmount / 1000000).toFixed(1)}M, requires $20M)`);
                }
              }
              
              // Check if custom category text was provided
              if (booking.additionalCategoryText && booking.additionalCategoryText.trim().length > 0) {
                reasons.push('Custom usage category details provided');
              }
              
              // Check if usage category is not approved for site
              if (booking.usageCategoryId) {
                const { isCategoryApprovedForSite, getApprovedCategoriesForSite } = await import('./usageCategoriesDb');
                const approvedCategories = await getApprovedCategoriesForSite(booking.siteId);
                
                if (approvedCategories.length > 0) {
                  const isApproved = await isCategoryApprovedForSite(booking.siteId, booking.usageCategoryId);
                  
                  if (!isApproved) {
                    const { getAllUsageCategories } = await import('./usageCategoriesDb');
                    const allCategories = await getAllUsageCategories();
                    const category = allCategories.find(c => c.id === booking.usageCategoryId);
                    reasons.push(`Usage category "${category?.name || 'Unknown'}" not approved for this site`);
                  } else {
                    // Check for overlapping bookings from OTHER customers (category exclusivity)
                    const { getDb } = await import('./db');
                    const { bookings: bookingsTable, sites: sitesTable } = await import('../drizzle/schema');
                    const { eq, and, ne, or, lte, gte } = await import('drizzle-orm');
                    const dbInstance = await getDb();
                    
                    if (dbInstance && site) {
                      const overlappingBookings = await dbInstance.select()
                        .from(bookingsTable)
                        .innerJoin(sitesTable, eq(bookingsTable.siteId, sitesTable.id))
                        .where(and(
                          ne(bookingsTable.customerId, booking.customerId), // DIFFERENT customer
                          eq(bookingsTable.usageCategoryId, booking.usageCategoryId), // SAME category
                          eq(sitesTable.centreId, site.centreId), // SAME centre
                          ne(bookingsTable.id, booking.id), // DIFFERENT booking
                          or(
                            eq(bookingsTable.status, 'pending'),
                            eq(bookingsTable.status, 'confirmed')
                          ), // Only active bookings
                          // Date overlap check
                          lte(bookingsTable.startDate, booking.endDate),
                          gte(bookingsTable.endDate, booking.startDate)
                        ));
                      
                      if (overlappingBookings.length > 0) {
                        reasons.push('Category conflict: another customer has overlapping booking with same category at this centre');
                      }
                    }
                  }
                }
              }
              
              // Check if site requires manual approval (no instant booking)
              if (!site?.instantBooking) {
                reasons.push('Site requires manual approval for all bookings');
              }
              
              // Check legacy custom usage
              if (booking.customUsage) {
                reasons.push('Custom usage type specified');
              }
              
              // Combine all reasons or use default
              if (reasons.length > 0) {
                approvalReason = reasons.join('; ');
              }
              
              return {
                ...booking,
                centreName: centre?.name || 'Unknown Centre',
                siteNumber: site?.siteNumber || 'Unknown',
                siteDescription: site?.description,
                customerName: customer?.name || 'Unknown Customer',
                customerEmail: customer?.email,
                usageTypeName: usageType?.name,
                approvalReason,
                insuranceExpired,
              };
            })
        );
        
        return bookingsWithDetails;
      }),

    approveBooking: adminProcedure
      .input(z.object({ bookingId: z.number() }))
      .mutation(async ({ ctx, input }) => {
        await db.approveBooking(input.bookingId, ctx.user.id);
        
        // Get booking details for notification
        const booking = await db.getBookingById(input.bookingId);
        const site = booking ? await db.getSiteById(booking.siteId) : null;
        const centre = site ? await db.getShoppingCentreById(site.centreId) : null;
        
        // Notify owner
        await notifyOwner({
          title: 'Booking Approved',
          content: `Booking #${booking?.bookingNumber} at ${centre?.name} - Site ${site?.siteNumber} has been approved.`,
        });
        
        // TODO: Send confirmation email to customer
        
        return { success: true };
      }),

    rejectBooking: adminProcedure
      .input(z.object({ bookingId: z.number(), reason: z.string().optional() }))
      .mutation(async ({ input }) => {
        await db.rejectBooking(input.bookingId, input.reason || "No reason provided");
        
        // Get booking details for notification
        const booking = await db.getBookingById(input.bookingId);
        const site = booking ? await db.getSiteById(booking.siteId) : null;
        const centre = site ? await db.getShoppingCentreById(site.centreId) : null;
        
        // Notify owner
        await notifyOwner({
          title: 'Booking Rejected',
          content: `Booking #${booking?.bookingNumber} at ${centre?.name} - Site ${site?.siteNumber} has been rejected.`,
        });
        
        // TODO: Send rejection email to customer with reason
        
        return { success: true };
      }),

    bulkCreateSeasonalRates: adminProcedure
      .input(z.object({
        centreIds: z.array(z.number()),
        name: z.string(),
        startDate: z.string(),
        endDate: z.string(),
        percentageIncrease: z.number(),
      }))
      .mutation(async ({ input }) => {
        const { centreIds, name, startDate, endDate, percentageIncrease } = input;
        
        // Get all sites for the selected centres
        const allSites = [];
        for (const centreId of centreIds) {
          const sites = await db.getSitesByCentreId(centreId);
          allSites.push(...sites);
        }

        // Create seasonal rates for each site
        let created = 0;
        for (const site of allSites) {
          // Calculate increased rates
          const multiplier = 1 + (percentageIncrease / 100);
          const baseWeekdayRate = site.pricePerDay ? parseFloat(site.pricePerDay) : 0;
          const baseWeekendRate = site.weekendPricePerDay ? parseFloat(site.weekendPricePerDay) : 0;
          
          const weekdayRate = baseWeekdayRate > 0 ? Math.round(baseWeekdayRate * multiplier * 100) / 100 : undefined;
          // If weekend rate is $0 or null, use weekday rate as base for percentage increase
          const weekendRate = baseWeekendRate > 0 
            ? Math.round(baseWeekendRate * multiplier * 100) / 100 
            : (baseWeekdayRate > 0 ? Math.round(baseWeekdayRate * multiplier * 100) / 100 : undefined);
          const weeklyRate = site.pricePerWeek ? Math.round(parseFloat(site.pricePerWeek) * multiplier * 100) / 100 : undefined;

          await createSeasonalRate({
            siteId: site.id,
            name,
            startDate,
            endDate,
            weekdayRate,
            weekendRate,
            weeklyRate,
          });
          created++;
        }

        return { created, totalSites: allSites.length };
      }),

    // Invoice Payment Management
    searchInvoiceBookings: adminProcedure
      .input(z.object({ query: z.string() }))
      .query(async ({ input }) => {
        return await db.searchInvoiceBookings(input.query);
      }),

    recordPayment: adminProcedure
      .input(z.object({ bookingId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        return await db.recordPayment(input.bookingId, ctx.user.name || 'Admin');
      }),

    triggerPaymentReminders: adminProcedure
      .mutation(async () => {
        const { sendPaymentReminders } = await import('./paymentReminders');
        return await sendPaymentReminders();
      }),

    // Invoice Dashboard
    getInvoiceStats: adminProcedure
      .query(async () => {
        const { getInvoiceStats } = await import('./invoiceDashboardDb');
        return await getInvoiceStats();
      }),

    getInvoiceList: adminProcedure
      .input(z.object({
        filter: z.enum(['all', 'outstanding', 'overdue', 'paid']).default('all'),
      }))
      .query(async ({ input }) => {
        const { getInvoiceList } = await import('./invoiceDashboardDb');
        return await getInvoiceList(input.filter);
      }),

    getPaymentHistory: adminProcedure
      .input(z.object({
        searchTerm: z.string().optional(),
      }))
      .query(async ({ input }) => {
        const { getPaymentHistory } = await import('./invoiceDashboardDb');
        return await getPaymentHistory(input.searchTerm);
      }),

    // User Registration
    registerUser: adminProcedure
      .input(z.object({
        email: z.string().email(),
        name: z.string(),
        password: z.string().min(8),
        role: z.enum([
          'customer',
          'owner_centre_manager',
          'owner_marketing_manager',
          'owner_regional_admin',
          'owner_state_admin',
          'owner_super_admin',
          'mega_state_admin',
          'mega_admin'
        ]).default('customer'),
        canPayByInvoice: z.boolean().default(false),
        // Company details
        companyName: z.string().optional(),
        companyWebsite: z.string().optional(),
        abn: z.string().optional(),
        address: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        postcode: z.string().optional(),
        productService: z.string().optional(),
        // Insurance details
        insuranceCompany: z.string().optional(),
        insurancePolicyNo: z.string().optional(),
        insuranceAmount: z.string().optional(),
        insuranceExpiryDate: z.string().optional(),
      }))
      .mutation(async ({ input }) => {
        // Check if user already exists
        const existingUser = await db.getUserByEmail(input.email);
        if (existingUser) {
          throw new TRPCError({ code: 'CONFLICT', message: 'User with this email already exists' });
        }

        // Create user with hashed password
        const bcrypt = await import('bcryptjs');
        const hashedPassword = await bcrypt.hash(input.password, 10);

        const { getDb } = await import('./db');
        const { users } = await import('../drizzle/schema');
        const dbInstance = await getDb();
        
        if (!dbInstance) {
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Database connection failed' });
        }

        // Generate a unique openId for the user
        const openId = `manual_${Date.now()}_${Math.random().toString(36).substring(7)}`;

        const [newUser] = await dbInstance.insert(users).values({
          openId,
          email: input.email,
          name: input.name,
          role: input.role,
          canPayByInvoice: input.canPayByInvoice,
        });

        // Create customer profile if company or insurance details provided
        if (input.companyName || input.insuranceCompany) {
          const { customerProfiles } = await import('../drizzle/schema');
          await dbInstance.insert(customerProfiles).values({
            userId: newUser.insertId,
            companyName: input.companyName || null,
            website: input.companyWebsite || null,
            abn: input.abn || null,
            streetAddress: input.address || null,
            city: input.city || null,
            state: input.state || null,
            postcode: input.postcode || null,
            productCategory: input.productService || null,
            insuranceCompany: input.insuranceCompany || null,
            insurancePolicyNo: input.insurancePolicyNo || null,
            insuranceAmount: input.insuranceAmount || null,
            insuranceExpiry: input.insuranceExpiryDate ? new Date(input.insuranceExpiryDate) : null,
          });
        }

        return { success: true, message: 'User registered successfully' };
      }),

    // Update User
    updateUser: adminProcedure
      .input(z.object({
        userId: z.number(),
        email: z.string().email().optional(),
        name: z.string().optional(),
        role: z.enum([
          'customer',
          'owner_centre_manager',
          'owner_marketing_manager',
          'owner_regional_admin',
          'owner_state_admin',
          'owner_super_admin',
          'mega_state_admin',
          'mega_admin'
        ]).optional(),
        canPayByInvoice: z.boolean().optional(),
        // Company details
        companyName: z.string().optional(),
        website: z.string().optional(),
        abn: z.string().optional(),
        streetAddress: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        postcode: z.string().optional(),
        productCategory: z.string().optional(),
        productDetails: z.string().optional(),
        // Insurance details
        insuranceCompany: z.string().optional(),
        insurancePolicyNo: z.string().optional(),
        insuranceAmount: z.string().optional(),
        insuranceExpiry: z.string().optional(),
        insuranceDocumentUrl: z.string().optional(),
      }))
      .mutation(async ({ input }) => {
        const { getDb } = await import('./db');
        const { users, customerProfiles } = await import('../drizzle/schema');
        const { eq } = await import('drizzle-orm');
        const dbInstance = await getDb();
        
        if (!dbInstance) {
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Database connection failed' });
        }

        // Update user basic info
        const userUpdates: any = {};
        if (input.email) userUpdates.email = input.email;
        if (input.name) userUpdates.name = input.name;
        if (input.role) userUpdates.role = input.role;
        if (input.canPayByInvoice !== undefined) userUpdates.canPayByInvoice = input.canPayByInvoice;

        if (Object.keys(userUpdates).length > 0) {
          await dbInstance.update(users).set(userUpdates).where(eq(users.id, input.userId));
        }

        // Update or create customer profile
        const profileUpdates: any = {};
        if (input.companyName !== undefined) profileUpdates.companyName = input.companyName || null;
        if (input.website !== undefined) profileUpdates.website = input.website || null;
        if (input.abn !== undefined) profileUpdates.abn = input.abn || null;
        if (input.streetAddress !== undefined) profileUpdates.streetAddress = input.streetAddress || null;
        if (input.city !== undefined) profileUpdates.city = input.city || null;
        if (input.state !== undefined) profileUpdates.state = input.state || null;
        if (input.postcode !== undefined) profileUpdates.postcode = input.postcode || null;
        if (input.productCategory !== undefined) profileUpdates.productCategory = input.productCategory || null;
        if (input.productDetails !== undefined) profileUpdates.productDetails = input.productDetails || null;
        if (input.insuranceCompany !== undefined) profileUpdates.insuranceCompany = input.insuranceCompany || null;
        if (input.insurancePolicyNo !== undefined) profileUpdates.insurancePolicyNo = input.insurancePolicyNo || null;
        if (input.insuranceAmount !== undefined) profileUpdates.insuranceAmount = input.insuranceAmount || null;
        if (input.insuranceExpiry !== undefined) profileUpdates.insuranceExpiry = input.insuranceExpiry ? new Date(input.insuranceExpiry) : null;
        if (input.insuranceDocumentUrl !== undefined) profileUpdates.insuranceDocumentUrl = input.insuranceDocumentUrl || null;

        if (Object.keys(profileUpdates).length > 0) {
          // Check if profile exists
          const existingProfile = await dbInstance.select().from(customerProfiles).where(eq(customerProfiles.userId, input.userId)).limit(1);
          
          if (existingProfile.length > 0) {
            // Update existing profile
            await dbInstance.update(customerProfiles).set(profileUpdates).where(eq(customerProfiles.userId, input.userId));
          } else {
            // Create new profile
            await dbInstance.insert(customerProfiles).values({
              userId: input.userId,
              ...profileUpdates,
            });
          }
        }

        return { success: true, message: 'User updated successfully' };
      }),
  }),

  // Usage Categories
  usageCategories: router({
    list: publicProcedure.query(async () => {
      return await getAllUsageCategories();
    }),
    
    getApprovedForSite: publicProcedure
      .input(z.object({ siteId: z.number() }))
      .query(async ({ input }) => {
        return await getApprovedCategoriesForSite(input.siteId);
      }),
    
    getSitesWithCategories: adminProcedure
      .input(z.object({ centreId: z.number() }))
      .query(async ({ input }) => {
        return await getSitesWithCategoriesForCentre(input.centreId);
      }),
    
    setApprovedCategories: adminProcedure
      .input(z.object({
        siteId: z.number(),
        categoryIds: z.array(z.number()),
      }))
      .mutation(async ({ input }) => {
        await setApprovedCategoriesForSite(input.siteId, input.categoryIds);
        return { success: true };
      }),
    
    createCategory: adminProcedure
      .input(z.object({
        name: z.string().min(1),
        isFree: z.boolean(),
        displayOrder: z.number().int().positive(),
      }))
      .mutation(async ({ input }) => {
        const { createUsageCategory } = await import("./usageCategoriesDb");
        const categoryId = await createUsageCategory(input.name, input.isFree, input.displayOrder);
        return { success: true, categoryId };
      }),
    
    applyToAllSites: adminProcedure
      .input(z.object({
        centreId: z.number(),
        categoryIds: z.array(z.number()),
      }))
      .mutation(async ({ input }) => {
        const { applyApprovalsToAllSitesInCentre } = await import("./usageCategoriesDb");
        const sitesUpdated = await applyApprovalsToAllSitesInCentre(input.centreId, input.categoryIds);
        return { success: true, sitesUpdated };
      }),
  }),

  // System Configuration
  users: router({
    list: adminProcedure.query(async () => {
      return await db.getAllUsers();
    }),

    updateInvoiceFlag: adminProcedure
      .input(z.object({
        userId: z.number(),
        canPayByInvoice: z.boolean(),
      }))
      .mutation(async ({ input, ctx }) => {
        // Only mega_admin and owner_super_admin can modify invoice payment flag
        if (ctx.user.role !== "mega_admin" && ctx.user.role !== "owner_super_admin") {
          throw new TRPCError({ code: "FORBIDDEN", message: "Only SuperAdmin can modify invoice payment settings" });
        }
        await db.updateUserInvoiceFlag(input.userId, input.canPayByInvoice);
        return { success: true };
      }),
  }),

  searchAnalytics: router({
    getSummary: adminProcedure
      .input(z.object({
        startDate: z.date().optional(),
        endDate: z.date().optional(),
      }))
      .query(async ({ input }) => {
        const { getSearchAnalyticsSummary } = await import("./searchAnalyticsDb");
        return await getSearchAnalyticsSummary(input);
      }),

    getPopularSearches: adminProcedure
      .input(z.object({
        limit: z.number().optional().default(10),
        startDate: z.date().optional(),
        endDate: z.date().optional(),
      }))
      .query(async ({ input }) => {
        const { getPopularSearches } = await import("./searchAnalyticsDb");
        return await getPopularSearches(input);
      }),

    getFailedSearches: adminProcedure
      .input(z.object({
        limit: z.number().optional().default(10),
        startDate: z.date().optional(),
        endDate: z.date().optional(),
      }))
      .query(async ({ input }) => {
        const { getFailedSearches } = await import("./searchAnalyticsDb");
        return await getFailedSearches(input);
      }),

    getSuggestionClickThroughRate: adminProcedure
      .input(z.object({
        startDate: z.date().optional(),
        endDate: z.date().optional(),
      }))
      .query(async ({ input }) => {
        const { getSuggestionClickThroughRate } = await import("./searchAnalyticsDb");
        return await getSuggestionClickThroughRate(input);
      }),
  }),

  systemConfig: router({
    getGstPercentage: publicProcedure.query(async () => {
      const value = await getConfigValue("gst_percentage");
      return { gstPercentage: value ? parseFloat(value) : 10.0 };
    }),

    setGstPercentage: adminProcedure
      .input(z.object({ gstPercentage: z.number().min(0).max(100) }))
      .mutation(async ({ input, ctx }) => {
        // Only mega_admin and owner_super_admin can change GST
        if (ctx.user.role !== "mega_admin" && ctx.user.role !== "owner_super_admin") {
          throw new TRPCError({ code: "FORBIDDEN", message: "Only SuperAdmin can change GST percentage" });
        }
        await setConfigValue("gst_percentage", input.gstPercentage.toString());
        return { success: true, gstPercentage: input.gstPercentage };
      }),
  }),
});

export type AppRouter = typeof appRouter;
