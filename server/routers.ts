import { COOKIE_NAME } from "@shared/const";
import { getSessionCookieOptions } from "./_core/cookies";
import { systemRouter } from "./_core/systemRouter";
import { publicProcedure, protectedProcedure, router } from "./_core/trpc";
import { z } from "zod";
import * as db from "./db";
import { getSystemConfig as getSystemConfigDb, updateSystemConfig as updateSystemConfigDb, getConfigValue, setConfigValue } from "./systemConfigDb";
import { trackImageView, trackImageClick, getTopPerformingImages, getImageAnalyticsBySite } from "./imageAnalyticsDb";
import { getSeasonalRatesBySiteId, createSeasonalRate, updateSeasonalRate, deleteSeasonalRate } from "./seasonalRatesDb";
import { getAllUsageCategories, getApprovedCategoriesForSite, setApprovedCategoriesForSite, getSitesWithCategoriesForCentre } from "./usageCategoriesDb";
import * as assetDb from "./assetDb";
import { TRPCError } from "@trpc/server";
import { notifyOwner } from "./_core/notification";
import { sendBookingConfirmationEmail, sendBookingRejectionEmail, sendNewBookingNotificationToOwner } from "./_core/bookingNotifications";

// Admin-only procedure
const adminProcedure = protectedProcedure.use(({ ctx, next }) => {
  if (ctx.user.role === 'customer') {
    throw new TRPCError({ code: 'FORBIDDEN', message: 'Admin access required' });
  }
  return next({ ctx });
});

export const appRouter = router({
  system: systemRouter,
  
  auth: router({
    me: publicProcedure.query(opts => opts.ctx.user),
    logout: publicProcedure.mutation(({ ctx }) => {
      const cookieOptions = getSessionCookieOptions(ctx.req);
      ctx.res.clearCookie(COOKIE_NAME, { ...cookieOptions, maxAge: -1 });
      return { success: true } as const;
    }),
    checkEmailAvailable: publicProcedure
      .input(z.object({ email: z.string().email() }))
      .query(async ({ input }) => {
        const { getUserByEmail } = await import('./db');
        const existingUser = await getUserByEmail(input.email);
        return { available: !existingUser };
      }),
  }),

  // Shopping Centres
  centres: router({
    list: publicProcedure.query(async () => {
      return await db.getShoppingCentres();
    }),
    
    search: publicProcedure
      .input(z.object({ query: z.string() }))
      .query(async ({ input }) => {
        return await db.searchShoppingCentres(input.query);
      }),
    
    getById: publicProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        const centre = await db.getShoppingCentreById(input.id);
        if (!centre) throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
        return centre;
      }),
    
    getSites: publicProcedure
      .input(z.object({ centreId: z.number() }))
      .query(async ({ input }) => {
        return await db.getSitesByCentreId(input.centreId);
      }),
    
    getByState: publicProcedure
      .input(z.object({ state: z.string() }))
      .query(async ({ input }) => {
        return await db.getShoppingCentresByState(input.state);
      }),
    
    getNearby: publicProcedure
      .input(z.object({ 
        centreId: z.number(),
        radiusKm: z.number().optional().default(10),
      }))
      .query(async ({ input }) => {
        return await db.getNearbyCentres(input.centreId, input.radiusKm);
      }),
    
    listWithCodes: adminProcedure.query(async () => {
      const { generateAbbreviatedCentreCode } = await import('./centreCodeHelper');
      const centres = await db.getShoppingCentres();
      
      return centres.map(centre => ({
        id: centre.id,
        name: centre.name,
        currentCode: centre.centreCode,
        autoGeneratedCode: generateAbbreviatedCentreCode(centre.name),
        state: centre.state,
        city: centre.city,
      }));
    }),
    
    updateCentreCode: adminProcedure
      .input(z.object({
        centreId: z.number(),
        centreCode: z.string().length(4).regex(/^[A-Z]{4}$/, 'Code must be 4 uppercase letters'),
      }))
      .mutation(async ({ input }) => {
        // Check if code is already used by another centre
        const centres = await db.getShoppingCentres();
        const existing = centres.find(c => 
          c.centreCode === input.centreCode && c.id !== input.centreId
        );
        
        if (existing) {
          throw new TRPCError({ 
            code: 'BAD_REQUEST', 
            message: `Code ${input.centreCode} is already used by ${existing.name}` 
          });
        }
        
        await db.updateShoppingCentre(input.centreId, { 
          centreCode: input.centreCode 
        });
        
        return { success: true };
      }),
    
    update: protectedProcedure
      .input(z.object({
        id: z.number(),
        name: z.string().min(1).optional(),
        address: z.string().optional(),
        suburb: z.string().optional(),
        state: z.string().optional(),
        postcode: z.string().optional(),
        description: z.string().optional(),
        contactPhone: z.string().optional(),
        contactEmail: z.string().email().optional(),
        operatingHours: z.string().optional(),
        policies: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const centre = await db.getShoppingCentreById(input.id);
        if (!centre) {
          throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
        }
        
        // Update centre
        await db.updateShoppingCentre(input.id, input);
        
        return { success: true, message: "Centre updated successfully" };
      }),
    
    updateWeeklyReportSettings: protectedProcedure
      .input(z.object({
        id: z.number(),
        weeklyReportEmail1: z.string().email().nullable().optional(),
        weeklyReportEmail2: z.string().email().nullable().optional(),
        weeklyReportEmail3: z.string().email().nullable().optional(),
        weeklyReportEmail4: z.string().email().nullable().optional(),
        weeklyReportEmail5: z.string().email().nullable().optional(),
        weeklyReportEmail6: z.string().email().nullable().optional(),
        weeklyReportEmail7: z.string().email().nullable().optional(),
        weeklyReportEmail8: z.string().email().nullable().optional(),
        weeklyReportEmail9: z.string().email().nullable().optional(),
        weeklyReportEmail10: z.string().email().nullable().optional(),
        weeklyReportTimezone: z.string().optional(),
        weeklyReportNextOverrideDay: z.enum(["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]).nullable().optional(),
      }))
      .mutation(async ({ input }) => {
        const centre = await db.getShoppingCentreById(input.id);
        if (!centre) {
          throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
        }
        
        await db.updateShoppingCentre(input.id, input);
        return { success: true, message: "Weekly report settings updated successfully" };
      }),
    
    sendTestWeeklyReport: protectedProcedure
      .input(z.object({ centreId: z.number() }))
      .mutation(async ({ input }) => {
        const { triggerWeeklyReport } = await import("./reportScheduler");
        const result = await triggerWeeklyReport(input.centreId);
        
        if (!result.success) {
          throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: result.message });
        }
        
        return { success: true, message: "Test report sent successfully" };
      }),
  }),

  // Sites
  sites: router({
    getByCentreId: publicProcedure
      .input(z.object({ centreId: z.number() }))
      .query(async ({ input }) => {
        return await db.getSitesByCentreId(input.centreId);
      }),
    getById: publicProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        const site = await db.getSiteById(input.id);
        if (!site) throw new TRPCError({ code: "NOT_FOUND", message: "Site not found" });
        return site;
      }),
    
    checkAvailability: publicProcedure
      .input(z.object({
        siteId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
      }))
      .query(async ({ input }) => {
        const bookings = await db.getBookingsBySiteId(input.siteId, input.startDate, input.endDate);
        return {
          available: bookings.length === 0,
          bookings: bookings.map(b => ({
            id: b.id,
            startDate: b.startDate,
            endDate: b.endDate,
            status: b.status,
          })),
        };
      }),

    getApprovedCategories: publicProcedure
      .input(z.object({ siteId: z.number() }))
      .query(async ({ input }) => {
        const { getApprovedCategoriesForSite } = await import("./usageCategoriesDb");
        return await getApprovedCategoriesForSite(input.siteId);
      }),

    setApprovedCategories: protectedProcedure
      .input(z.object({
        siteId: z.number(),
        categoryIds: z.array(z.number()),
      }))
      .mutation(async ({ input, ctx }) => {
        // Only owners and mega admins can manage site categories
        const allowedRoles = ['owner_super_admin', 'owner_state_admin', 'owner_regional_admin', 'owner_centre_manager', 'mega_admin', 'mega_state_admin'];
        if (!allowedRoles.includes(ctx.user.role)) {
          throw new TRPCError({ code: 'FORBIDDEN', message: 'Only owners and administrators can manage site categories' });
        }

        const { setApprovedCategoriesForSite } = await import("./usageCategoriesDb");
        await setApprovedCategoriesForSite(input.siteId, input.categoryIds);
        return { success: true };
      }),
  }),

  // Bookings
  bookings: router({
    create: protectedProcedure
      .input(z.object({
        siteId: z.number(),
        usageTypeId: z.number().optional(), // legacy field
        customUsage: z.string().optional(), // legacy field
        usageCategoryId: z.number().optional(),
        additionalCategoryText: z.string().optional(),
        startDate: z.date(),
        endDate: z.date(),
        tablesRequested: z.number().optional().default(0),
        chairsRequested: z.number().optional().default(0),
      }))
      .mutation(async ({ input, ctx }) => {
        // Check availability
        const existingBookings = await db.getBookingsBySiteId(input.siteId, input.startDate, input.endDate);
        if (existingBookings.length > 0) {
          throw new TRPCError({ code: "CONFLICT", message: "Site is already booked for this period" });
        }

        // Get site details for pricing
        const site = await db.getSiteById(input.siteId);
        if (!site) throw new TRPCError({ code: "NOT_FOUND", message: "Site not found" });

        // Calculate booking duration and price with weekend rate support
        const { totalAmount, weekdayCount, weekendCount } = await import("./bookingCalculation").then(m => 
          m.calculateBookingCost(site, input.startDate, input.endDate)
        );

        // Get GST rate
        const gstValue = await getConfigValue("gst_percentage");
        const gstRate = gstValue ? Number(gstValue) / 100 : 0.1;
        const gstAmount = totalAmount * gstRate;

        // Get centre and owner info for commission
        const centre = await db.getShoppingCentreById(site.centreId);
        if (!centre) throw new TRPCError({ code: "NOT_FOUND", message: "Centre not found" });
        
        const owner = await db.getOwnerById(centre.ownerId);
        if (!owner) throw new TRPCError({ code: "NOT_FOUND", message: "Owner not found" });

        const platformFee = totalAmount * (Number(owner.commissionPercentage) / 100);
        const ownerAmount = totalAmount - platformFee;

        // Generate booking number with abbreviated centre code: {CODE}-{YYYYMMDD}-{SEQ}
        // Example: CAMP-20260601-001 (Campbelltown Mall)
        const { getCentreCodeForBooking } = await import('./centreCodeHelper');
        const centreCode = getCentreCodeForBooking(centre);
        const dateStr = new Date(input.startDate).toISOString().split('T')[0].replace(/-/g, ''); // YYYYMMDD
        const randomSeq = Math.floor(Math.random() * 1000).toString().padStart(3, '0'); // 001-999
        const bookingNumber = `${centreCode}-${dateStr}-${randomSeq}`;

        // Check equipment availability if requested
        let equipmentWarning: string | undefined;
        if ((input.tablesRequested || 0) > 0 || (input.chairsRequested || 0) > 0) {
          const { checkEquipmentAvailability } = await import("./equipmentAvailability");
          const equipmentCheck = await checkEquipmentAvailability(
            site.centreId,
            input.startDate,
            input.endDate,
            input.tablesRequested || 0,
            input.chairsRequested || 0
          );
          
          if (!equipmentCheck.available) {
            equipmentWarning = equipmentCheck.message;
          }
        }

        // Determine if approval is needed based on usage categories
        let requiresApproval = false;
        
        if (input.usageCategoryId) {
          // Check if additional text was provided (triggers manual approval)
          if (input.additionalCategoryText && input.additionalCategoryText.trim().length > 0) {
            requiresApproval = true;
          } else {
            // Check if category is approved for this site
            const { isCategoryApprovedForSite, getApprovedCategoriesForSite } = await import("./usageCategoriesDb");
            const approvedCategories = await getApprovedCategoriesForSite(input.siteId);
            
            // If no approvals exist (empty), treat as all approved (default behavior - skip duplicate check)
            if (approvedCategories.length === 0) {
              // Default all approved - no additional checks needed
              requiresApproval = false;
            } else {
              // Approvals exist - check if this specific category is approved
              const isApproved = await isCategoryApprovedForSite(input.siteId, input.usageCategoryId);
              
              if (!isApproved) {
                requiresApproval = true;
              } else {
                // Category is explicitly approved - check for overlapping bookings from OTHER customers
                // This ensures category exclusivity: only one vendor per category at a time
              const { getDb } = await import("./db");
              const { bookings, sites: sitesTable } = await import("../drizzle/schema");
              const { eq, and, ne, or, lte, gte } = await import("drizzle-orm");
              const dbInstance = await getDb();
              if (dbInstance) {
                // Get the centre ID for the current site
                const currentSite = await dbInstance.select().from(sitesTable)
                  .where(eq(sitesTable.id, input.siteId))
                  .limit(1);
                
                if (currentSite.length > 0) {
                  const centreId = currentSite[0].centreId;
                  
                  // Find overlapping bookings from DIFFERENT customers with same category at same centre
                  // Date overlap logic: (newStart <= existingEnd) AND (newEnd >= existingStart)
                  const overlappingBookings = await dbInstance.select({
                    bookingId: bookings.id,
                    customerId: bookings.customerId,
                    startDate: bookings.startDate,
                    endDate: bookings.endDate,
                  })
                    .from(bookings)
                    .innerJoin(sitesTable, eq(bookings.siteId, sitesTable.id))
                    .where(and(
                      ne(bookings.customerId, ctx.user.id), // DIFFERENT customer
                      eq(bookings.usageCategoryId, input.usageCategoryId), // SAME category
                      eq(sitesTable.centreId, centreId), // SAME centre
                      or(
                        eq(bookings.status, 'pending'),
                        eq(bookings.status, 'confirmed')
                      ), // Only active bookings
                      // Date overlap check
                      lte(bookings.startDate, input.endDate),
                      gte(bookings.endDate, input.startDate)
                    ));
                  
                  if (overlappingBookings.length > 0) {
                    requiresApproval = true;
                  }
                }
              }
              }
            }
          }
        } else if (input.customUsage) {
          // Legacy: custom usage always requires approval
          requiresApproval = true;
        } else if (input.usageTypeId) {
          // Legacy: check old usage types
          const usageType = await db.getUsageTypes();
          const selectedUsage = usageType.find(u => u.id === input.usageTypeId);
          if (selectedUsage?.requiresApproval) {
            requiresApproval = true;
          }
        }

        // Check if user can pay by invoice
        const currentUser = await db.getUserByOpenId(ctx.user.openId);
        const canPayByInvoice = currentUser?.canPayByInvoice || false;

        // Check insurance expiry date
        const customerProfile = await db.getCustomerProfileByUserId(ctx.user.id);
        let insuranceExpired = false;
        
        if (customerProfile?.insuranceExpiry) {
          const insuranceExpiryDate = new Date(customerProfile.insuranceExpiry);
          const bookingEndDate = new Date(input.endDate);
          
          // If insurance expires before booking end date, flag for manual approval
          if (insuranceExpiryDate < bookingEndDate) {
            requiresApproval = true;
            insuranceExpired = true;
          }
        }

        // Calculate payment due date for invoice bookings (7 days from booking creation)
        const paymentDueDate = canPayByInvoice ? new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) : null;

        // Create booking
        const result = await db.createBooking({
          bookingNumber,
          siteId: input.siteId,
          customerId: ctx.user.id,
          usageTypeId: input.usageTypeId,
          customUsage: input.customUsage,
          usageCategoryId: input.usageCategoryId,
          additionalCategoryText: input.additionalCategoryText,
          startDate: input.startDate,
          endDate: input.endDate,
          totalAmount: totalAmount.toFixed(2),
          gstAmount: gstAmount.toFixed(2),
          gstPercentage: (gstRate * 100).toFixed(2), // Store GST percentage at time of booking
          ownerAmount: ownerAmount.toFixed(2),
          platformFee: platformFee.toFixed(2),
          paymentMethod: canPayByInvoice ? "invoice" : "stripe",
          paymentDueDate: paymentDueDate,
          status: requiresApproval ? "pending" : (site.instantBooking ? "confirmed" : "pending"),
          requiresApproval,
          tablesRequested: input.tablesRequested || 0,
          chairsRequested: input.chairsRequested || 0,
        });

        return {
          bookingId: Number(result[0].insertId),
          bookingNumber,
          totalAmount,
          requiresApproval,
          insuranceExpired,
          canPayByInvoice,
          paymentMethod: canPayByInvoice ? "invoice" as const : "stripe" as const,
          equipmentWarning,
          costBreakdown: {
            weekdayCount,
            weekendCount,
            weekdayRate: Number(site.pricePerDay),
            weekendRate: site.weekendPricePerDay ? Number(site.weekendPricePerDay) : Number(site.pricePerDay),
            subtotal: totalAmount,
            gstAmount,
            total: totalAmount + gstAmount,
          },
        };
      }),

    calculatePreview: publicProcedure
      .input(z.object({
        siteId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
      }))
      .query(async ({ input }) => {
        // Get site details for pricing
        const site = await db.getSiteById(input.siteId);
        if (!site) throw new TRPCError({ code: "NOT_FOUND", message: "Site not found" });

        // Calculate booking cost with seasonal rates
        const { totalAmount, weekdayCount, weekendCount, seasonalDays } = await import("./bookingCalculation").then(m => 
          m.calculateBookingCost(site, input.startDate, input.endDate)
        );

        // Get GST rate
        const gstValue = await getConfigValue("gst_percentage");
        const gstRate = gstValue ? Number(gstValue) / 100 : 0.1;
        const gstAmount = totalAmount * gstRate;

        return {
          weekdayCount,
          weekendCount,
          weekdayRate: Number(site.pricePerDay),
          weekendRate: site.weekendPricePerDay ? Number(site.weekendPricePerDay) : Number(site.pricePerDay),
          subtotal: totalAmount,
          gstAmount,
          gstPercentage: gstRate * 100, // Return current GST percentage
          total: totalAmount + gstAmount,
          seasonalDays: seasonalDays || [],
        };
      }),

    myBookings: protectedProcedure.query(async ({ ctx }) => {
      return await db.getBookingsByCustomerId(ctx.user.id);
    }),

    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input, ctx }) => {
        const booking = await db.getBookingById(input.id);
        if (!booking) throw new TRPCError({ code: "NOT_FOUND", message: "Booking not found" });
        
        // Check if user owns this booking
        if (booking.customerId !== ctx.user.id) {
          throw new TRPCError({ code: "FORBIDDEN", message: "Not authorized" });
        }
        
        return booking;
      }),

    list: adminProcedure
      .input(z.object({
        status: z.enum(["pending", "confirmed", "cancelled", "completed", "unpaid"]).optional(),
      }))
      .query(async ({ input }) => {
        // Handle "unpaid" status specially - it's not a database status
        if (input.status === "unpaid") {
          return await db.getUnpaidInvoiceBookings();
        }
        return await db.getBookingsByStatus(input.status);
      }),

    approve: adminProcedure
      .input(z.object({ bookingId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const booking = await db.getBookingById(input.bookingId);
        if (!booking) throw new TRPCError({ code: "NOT_FOUND", message: "Booking not found" });
        
        if (booking.status !== "pending") {
          throw new TRPCError({ code: "BAD_REQUEST", message: "Only pending bookings can be approved" });
        }

        await db.approveBooking(input.bookingId, ctx.user.id);
        
        // Send confirmation email to customer
        const site = await db.getSiteById(booking.siteId);
        const centre = site ? await db.getShoppingCentreById(site.centreId) : null;
        const customer = await db.getUserById(booking.customerId);
        
        if (customer && site && centre) {
          await sendBookingConfirmationEmail({
            bookingNumber: booking.bookingNumber,
            customerName: customer.name || "Customer",
            customerEmail: customer.email || "",
            centreName: centre.name,
            siteNumber: site.siteNumber,
            startDate: booking.startDate,
            endDate: booking.endDate,
            totalAmount: booking.totalAmount,
          });
        }
        
        return { success: true };
      }),

    reject: adminProcedure
      .input(z.object({ 
        bookingId: z.number(),
        reason: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        const booking = await db.getBookingById(input.bookingId);
        if (!booking) throw new TRPCError({ code: "NOT_FOUND", message: "Booking not found" });
        
        if (booking.status !== "pending") {
          throw new TRPCError({ code: "BAD_REQUEST", message: "Only pending bookings can be rejected" });
        }

        await db.rejectBooking(input.bookingId, input.reason);
        
        // Send rejection email to customer with reason
        const site = await db.getSiteById(booking.siteId);
        const centre = site ? await db.getShoppingCentreById(site.centreId) : null;
        const customer = await db.getUserById(booking.customerId);
        
        if (customer && site && centre) {
          await sendBookingRejectionEmail(
            {
              bookingNumber: booking.bookingNumber,
              customerName: customer.name || "Customer",
              customerEmail: customer.email || "",
              centreName: centre.name,
              siteNumber: site.siteNumber,
              startDate: booking.startDate,
              endDate: booking.endDate,
              totalAmount: booking.totalAmount,
            },
            input.reason || "No reason provided"
          );
        }
        
        return { success: true };
      }),

    getPendingApprovals: adminProcedure
      .input(z.object({
        status: z.enum(["pending", "confirmed", "rejected", "all"]).default("pending"),
      }))
      .query(async ({ input }) => {
        const { getDb } = await import("./db");
        const { bookings, sites, shoppingCentres, users, usageCategories } = await import("../drizzle/schema");
        const { eq, and, inArray } = await import("drizzle-orm");
        
        const db = await getDb();
        if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database connection failed" });

        // Build where clause based on status filter
        const whereClause = input.status === "all" 
          ? undefined 
          : eq(bookings.status, input.status);

        // Fetch bookings with joined data
        const bookingsList = await db
          .select({
            id: bookings.id,
            bookingNumber: bookings.bookingNumber,
            status: bookings.status,
            startDate: bookings.startDate,
            endDate: bookings.endDate,
            totalAmount: bookings.totalAmount,
            ownerAmount: bookings.ownerAmount,
            requiresApproval: bookings.requiresApproval,
            additionalCategoryText: bookings.additionalCategoryText,
            rejectionReason: bookings.rejectionReason,
            createdAt: bookings.createdAt,
            // Customer info
            customerId: users.id,
            customerName: users.name,
            customerEmail: users.email,
            // Site info
            siteId: sites.id,
            siteNumber: sites.siteNumber,
            // Centre info
            centreId: shoppingCentres.id,
            centreName: shoppingCentres.name,
            // Category info
            categoryId: usageCategories.id,
            categoryName: usageCategories.name,
          })
          .from(bookings)
          .innerJoin(users, eq(bookings.customerId, users.id))
          .innerJoin(sites, eq(bookings.siteId, sites.id))
          .innerJoin(shoppingCentres, eq(sites.centreId, shoppingCentres.id))
          .leftJoin(usageCategories, eq(bookings.usageCategoryId, usageCategories.id))
          .where(whereClause)
          .orderBy(bookings.createdAt);

        return bookingsList;
      }),
  }),

  // Customer Profile
  profile: router({
    get: protectedProcedure.query(async ({ ctx }) => {
      return await db.getCustomerProfileByUserId(ctx.user.id);
    }),

    update: protectedProcedure
      .input(z.object({
        firstName: z.string().optional(),
        lastName: z.string().optional(),
        phone: z.string().optional(),
        companyName: z.string().optional(),
        website: z.string().optional(),
        abn: z.string().optional(),
        streetAddress: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        postcode: z.string().optional(),
        productCategory: z.string().optional(),
        insuranceCompany: z.string().optional(),
        insurancePolicyNo: z.string().optional(),
        insuranceAmount: z.string().optional(),
        insuranceExpiry: z.date().optional(),
        insuranceDocumentUrl: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const existing = await db.getCustomerProfileByUserId(ctx.user.id);
        
        if (existing) {
          await db.updateCustomerProfile(ctx.user.id, input);
        } else {
          await db.createCustomerProfile({
            userId: ctx.user.id,
            ...input,
          });
        }
        
        return { success: true };
      }),

    uploadInsurance: protectedProcedure
      .input(z.object({
        fileData: z.string(), // base64 encoded file
        fileName: z.string(),
        mimeType: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        const { storagePut } = await import('./storage');
        
        // Extract base64 data from data URL (remove "data:image/png;base64," prefix)
        const base64Data = input.fileData.includes(',') 
          ? input.fileData.split(',')[1] 
          : input.fileData;
        
        // Decode base64 and upload to S3
        const buffer = Buffer.from(base64Data, 'base64');
        const fileKey = `insurance/${ctx.user.id}/${Date.now()}-${input.fileName}`;
        
        const { url } = await storagePut(fileKey, buffer, input.mimeType);
        
        return { url };
      }),

    scanInsurance: protectedProcedure
      .input(z.object({
        documentUrl: z.string(),
      }))
      .mutation(async ({ input }) => {
        const { scanInsuranceDocument, validateInsurance } = await import('./insuranceScanner');
        
        const scanResult = await scanInsuranceDocument(input.documentUrl);
        const validation = validateInsurance(scanResult);
        
        // Return scan result with validation warnings, but don't block
        return {
          ...scanResult,
          warnings: validation.valid ? [] : validation.errors,
        };
      }),
  }),

  // Usage Types
  usageTypes: router({
    list: publicProcedure.query(async () => {
      return await db.getUsageTypes();
    }),
  }),

  // Search with date
  search: router({
    // Smart search with site-level support
    smart: publicProcedure
      .input(z.object({ query: z.string(), date: z.date() }))
      .query(async ({ input, ctx }) => {
        // Parse query to extract requirements
        const { parseSearchQuery, siteMatchesRequirements } = await import("../shared/queryParser");
        const parsedQuery = parseSearchQuery(input.query);

        // If asset type is specified (VS or 3rdL), search only that type
        if (parsedQuery.assetType === 'vacant_shop') {
          const searchQuery = parsedQuery.centreName || input.query;
          const centres = await db.searchShoppingCentres(searchQuery);
          if (centres.length === 0) {
            return { centres: [], sites: [], availability: [], matchedSiteIds: [], assetType: 'vacant_shop', floorLevels: [] };
          }
          const allShops: any[] = [];
          for (const centre of centres) {
            const shops = await assetDb.getVacantShopsByCentre(centre.id);
            allShops.push(...shops.map((s: any) => ({ ...s, centreName: centre.name, assetType: 'vacant_shop' })));
          }
          // Fetch floor levels for the first centre to display floor plan map
          const floorLevels = centres.length > 0 ? await db.getFloorLevelsByCentre(centres[0].id) : [];
          return { centres, sites: allShops, availability: [], matchedSiteIds: [], assetType: 'vacant_shop', floorLevels };
        }
        
        if (parsedQuery.assetType === 'third_line') {
          const searchQuery = parsedQuery.centreName || input.query;
          const centres = await db.searchShoppingCentres(searchQuery);
          if (centres.length === 0) {
            return { centres: [], sites: [], availability: [], matchedSiteIds: [], assetType: 'third_line', floorLevels: [] };
          }
          const allAssets: any[] = [];
          for (const centre of centres) {
            const assets = await assetDb.getThirdLineIncomeByCentre(centre.id);
            const filtered = parsedQuery.thirdLineCategory 
              ? assets.filter((a: any) => a.categoryName?.toLowerCase().includes(parsedQuery.thirdLineCategory!.toLowerCase()))
              : assets;
            allAssets.push(...filtered.map((a: any) => ({ ...a, centreName: centre.name, assetType: 'third_line' })));
          }
          // Fetch floor levels for the first centre to display floor plan map
          const floorLevels = centres.length > 0 ? await db.getFloorLevelsByCentre(centres[0].id) : [];
          return { centres, sites: allAssets, availability: [], matchedSiteIds: [], assetType: 'third_line', floorLevels };
        }
        
        // First, search for sites using the full query to find any matches
        // This allows description-based searches like "Waverley Outside Prouds" to work
        const siteResults = await db.searchSitesWithCategory(input.query, parsedQuery.productCategory);
        
        // Determine if query has site-specific keywords beyond just centre name
        const lowerQuery = input.query.toLowerCase();
        
        // Check for explicit site-specific patterns
        const hasSiteNumber = /site\s*\d+|#\d+|\bsite\b/i.test(lowerQuery);
        const hasProductCategory = !!parsedQuery.productCategory;
        const hasSizeRequirement = parsedQuery.minSizeM2 !== undefined;
        const hasTableRequirement = parsedQuery.minTables !== undefined;
        
        // Check if the query contains more than just a centre name by looking at the actual
        // centre names from the site results. If the query is longer than the centre name,
        // it likely contains description keywords.
        let queryHasDescriptionKeywords = false;
        if (siteResults.length > 0 && siteResults.length < 10) {
          // Get the actual centre name from the matched sites
          const actualCentreName = siteResults[0].centre?.name?.toLowerCase() || '';
          // If the query is significantly longer than the centre name, it has extra keywords
          if (actualCentreName && lowerQuery.length > actualCentreName.length + 3) {
            queryHasDescriptionKeywords = true;
          }
        }
        
        // If we found specific site matches with description keywords,
        // or if there are explicit requirements, consider it a site-specific query
        const hasSiteSpecificQuery = queryHasDescriptionKeywords || 
          hasSiteNumber || hasProductCategory || hasSizeRequirement || hasTableRequirement;
        
        // For centre search, use the extracted centre name if available
        const searchQuery = parsedQuery.centreName || input.query;
        
        // If we found specific sites with category filter, extract their centres
        let centres: any[] = [];
        if (siteResults.length > 0 && parsedQuery.productCategory) {
          const centresMap = new Map();
          for (const result of siteResults) {
            if (!centresMap.has(result.site.centreId) && result.centre) {
              centresMap.set(result.site.centreId, result.centre);
            }
          }
          
          centres = Array.from(centresMap.values());
        } else {
          // Continue with regular search logic using the parsed centre name
          centres = await db.searchShoppingCentres(searchQuery);
        }
        
        if (centres.length === 0) {
          // Get search suggestions when no results found
          const { getSearchSuggestions } = await import("./searchSuggestions");
          const suggestions = await getSearchSuggestions(searchQuery, 5);
          
          // Log failed search
          const { logSearch } = await import("./searchAnalyticsDb");
          await logSearch({
            userId: ctx.user?.id,
            query: input.query,
            centreName: parsedQuery.centreName,
            minSizeM2: parsedQuery.minSizeM2,
            productCategory: parsedQuery.productCategory,
            resultsCount: 0,
            suggestionsShown: suggestions.length,
            searchDate: input.date,
          });
          
          return { 
            centres: [], 
            sites: [], 
            availability: [], 
            matchedSiteIds: [],
            suggestions // Add suggestions to response
          };
        }

        const startOfWeek = new Date(input.date);
        startOfWeek.setHours(0, 0, 0, 0);
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(endOfWeek.getDate() + 6);
        
        const startOfNextWeek = new Date(endOfWeek);
        startOfNextWeek.setDate(startOfNextWeek.getDate() + 1);
        const endOfNextWeek = new Date(startOfNextWeek);
        endOfNextWeek.setDate(endOfNextWeek.getDate() + 6);

        const allSites: any[] = [];
        const availability: any[] = [];
        
        // Populate matchedSiteIds based on the earlier computed hasSiteSpecificQuery
        const matchedSiteIds: number[] = hasSiteSpecificQuery ? siteResults.map(r => r.site.id) : [];
        
        // Track if any sites match the size requirement
        let hasMatchingSites = false;
        const hasRequirements = parsedQuery.minSizeM2 !== undefined || parsedQuery.minTables !== undefined || parsedQuery.productCategory !== undefined;
        
        // OPTIMIZED: Batch fetch all data in minimal queries
        const { getSearchDataOptimized } = await import("./dbOptimized");
        const centreIds = centres.map(c => c.id);
        
        let {
          sitesByCentre,
          week1BookingsBySite,
          week2BookingsBySite,
          categoriesBySite,
        } = await getSearchDataOptimized(
          centreIds,
          startOfWeek,
          endOfWeek,
          startOfNextWeek,
          endOfNextWeek
        );
        
        // Override sitesByCentre if we have category-filtered sites from searchSitesWithCategory
        if (parsedQuery.productCategory && siteResults.length > 0) {
          const tempSitesByCentre = new Map();
          for (const result of siteResults) {
            const centreId = result.site.centreId;
            if (!tempSitesByCentre.has(centreId)) {
              tempSitesByCentre.set(centreId, []);
            }
            tempSitesByCentre.get(centreId)!.push(result.site);
          }
          sitesByCentre = tempSitesByCentre;
        }
        
        // First pass: check if any sites match the requirements and find closest match
        let closestMatch: { sizeM2: number; widthM: number; lengthM: number; difference: number } | null = null;
        const requestedSizeM2 = parsedQuery.minSizeM2;
        
        for (const centre of centres) {
          const sites = sitesByCentre.get(centre.id) || [];
          
          // Check which sites match the requirements
          const sitesWithMatch = sites.map((site: any) => ({
            site,
            matchesRequirements: siteMatchesRequirements(site, parsedQuery),
            sizeMatch: requestedSizeM2 ? (site.sizeM2 === requestedSizeM2 ? 'perfect' : site.sizeM2 > requestedSizeM2 ? 'larger' : 'smaller') : null
          }));
          
          // Check if any sites match
          if (sitesWithMatch.some((s: any) => s.matchesRequirements)) {
            hasMatchingSites = true;
          }
          
          // Track closest match for size suggestions
          if (requestedSizeM2 && !hasMatchingSites) {
            for (const { site } of sitesWithMatch) {
              if (site.sizeM2 && site.sizeM2 >= requestedSizeM2) {
                const diff = Math.abs(site.sizeM2 - requestedSizeM2);
                if (!closestMatch || diff < closestMatch.difference) {
                  closestMatch = {
                    sizeM2: site.sizeM2,
                    widthM: site.widthM,
                    lengthM: site.lengthM,
                    difference: diff
                  };
                }
              }
            }
          }
        }
        
        // Second pass: collect sites based on whether matches were found
        const siteCategories: Record<number, any[]> = {};
        
        for (const centre of centres) {
          const sites = sitesByCentre.get(centre.id) || [];
          
          // Check which sites match the requirements
          const sitesWithMatch = sites.map((site: any) => ({
            site,
            matchesRequirements: siteMatchesRequirements(site, parsedQuery),
            sizeMatch: requestedSizeM2 ? (site.sizeM2 === requestedSizeM2 ? 'perfect' : site.sizeM2 > requestedSizeM2 ? 'larger' : 'smaller') : null
          }));
          
          // Determine which sites to include based on requirements
          let sitesToInclude = sitesWithMatch;
          if (hasRequirements && hasMatchingSites) {
            // If size/table requirements specified and matches found, only include matching sites
            sitesToInclude = sitesWithMatch.filter((s: any) => s.matchesRequirements);
          }
          
          const sitesWithData = sitesToInclude.map(({ site, sizeMatch }: any) => ({ ...site, centreName: centre.name, sizeMatch }));
          allSites.push(...sitesWithData);
          
          for (const { site } of sitesToInclude as any[]) {
            // Use pre-fetched data instead of individual queries
            const week1Bookings = week1BookingsBySite.get(site.id) || [];
            const week2Bookings = week2BookingsBySite.get(site.id) || [];
            const approvedCategories = categoriesBySite.get(site.id) || [];
            
            siteCategories[site.id] = approvedCategories;
            
            availability.push({
              siteId: site.id,
              siteNumber: site.siteNumber,
              centreName: centre.name,
              week1Available: week1Bookings.length === 0,
              week2Available: week2Bookings.length === 0,
              week1Bookings,
              week2Bookings,
            });
          }
        }
        
        // Return flag indicating if size requirement was met
        const sizeNotAvailable = hasRequirements && !hasMatchingSites;
        
        // Log successful search
        const { logSearch } = await import("./searchAnalyticsDb");
        await logSearch({
          userId: ctx.user?.id,
          query: input.query,
          centreName: parsedQuery.centreName,
          minSizeM2: parsedQuery.minSizeM2,
          productCategory: parsedQuery.productCategory,
          resultsCount: allSites.length,
          suggestionsShown: 0,
          searchDate: input.date,
        });
        
        // Fetch floor levels for the first centre to display floor plan map
        let floorLevels: any[] = [];
        if (centres.length > 0) {
          floorLevels = await db.getFloorLevelsByCentre(centres[0].id);
        }
        
        return { centres, sites: allSites, availability, matchedSiteIds, sizeNotAvailable, closestMatch, siteCategories, floorLevels };
      }),
    byNameAndDate: publicProcedure
      .input(z.object({
        centreName: z.string(),
        date: z.date(),
      }))
      .query(async ({ input }) => {
        // Search for centres matching the name
        const centres = await db.searchShoppingCentres(input.centreName);
        
        if (centres.length === 0) {
          return { centres: [], sites: [], availability: [] };
        }

        // Get the requested week start and end
        const startOfWeek = new Date(input.date);
        startOfWeek.setHours(0, 0, 0, 0);
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(endOfWeek.getDate() + 6);
        
        // Get the following week
        const startOfNextWeek = new Date(endOfWeek);
        startOfNextWeek.setDate(startOfNextWeek.getDate() + 1);
        const endOfNextWeek = new Date(startOfNextWeek);
        endOfNextWeek.setDate(endOfNextWeek.getDate() + 6);

        // Get all sites for these centres
        const allSites = [];
        const availability = [];
        
        for (const centre of centres) {
          const sites = await db.getSitesByCentreId(centre.id);
          allSites.push(...sites.map(s => ({ ...s, centreName: centre.name })));
          
          // Check availability for each site
          for (const site of sites) {
            const week1Bookings = await db.getBookingsBySiteId(site.id, startOfWeek, endOfWeek);
            const week2Bookings = await db.getBookingsBySiteId(site.id, startOfNextWeek, endOfNextWeek);
            
            availability.push({
              siteId: site.id,
              week1Available: week1Bookings.length === 0,
              week2Available: week2Bookings.length === 0,
              week1Bookings: week1Bookings.map(b => ({ startDate: b.startDate, endDate: b.endDate })),
              week2Bookings: week2Bookings.map(b => ({ startDate: b.startDate, endDate: b.endDate })),
            });
          }
        }

        return {
          centres,
          sites: allSites,
          availability,
          requestedWeek: { start: startOfWeek, end: endOfWeek },
          followingWeek: { start: startOfNextWeek, end: endOfNextWeek },
        };
      }),
  }),

  // Admin endpoints
  admin: router({
    getStats: adminProcedure.query(async () => {
      const centres = await db.getShoppingCentres();
      const sites = await db.getAllSites();
      const bookings = await db.getAllBookings();
      const users = await db.getAllUsers();
      
      const activeBookings = bookings.filter(
        (b) => b.status === 'confirmed' || b.status === 'pending'
      );
      
      const totalRevenue = bookings
        .filter((b: any) => b.status === 'confirmed' || b.status === 'completed')
        .reduce((sum: number, b: any) => sum + parseFloat(b.totalAmount), 0);
      
      const now = new Date();
      const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
      const monthlyRevenue = bookings
        .filter(
          (b: any) =>
            (b.status === 'confirmed' || b.status === 'completed') &&
            new Date(b.createdAt) >= monthStart
        )
        .reduce((sum: number, b: any) => sum + parseFloat(b.totalAmount), 0);
      
      const recentBookings = bookings
        .sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
        .slice(0, 5)
        .map((b: any) => ({
          id: b.id,
          siteName: `Site ${b.siteId}`,
          startDate: b.startDate,
          endDate: b.endDate,
          totalPrice: parseFloat(b.totalAmount),
          status: b.status,
        }));
      
      return {
        totalCentres: centres.length,
        totalSites: sites.length,
        activeBookings: activeBookings.length,
        totalRevenue,
        monthlyRevenue,
        totalUsers: users.length,
        recentBookings,
      };
    }),

    // Shopping Centre Management
    createCentre: adminProcedure
      .input(z.object({
        name: z.string(),
        address: z.string().optional(),
        suburb: z.string().optional(),
        state: z.string().optional(),
        postcode: z.string().optional(),
        description: z.string().optional(),
      }))
      .mutation(async ({ input }) => {
        return await db.createShoppingCentre({
          ...input,
          ownerId: 1, // Default owner, should be dynamic based on user
        });
      }),

    updateCentre: adminProcedure
      .input(z.object({
        id: z.number(),
        name: z.string(),
        address: z.string().optional(),
        suburb: z.string().optional(),
        state: z.string().optional(),
        postcode: z.string().optional(),
        description: z.string().optional(),
        includeInMainSite: z.boolean().optional(),
      }))
      .mutation(async ({ input }) => {
        return await db.updateShoppingCentre(input.id, input);
      }),

    deleteCentre: adminProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        return await db.deleteShoppingCentre(input.id);
      }),

    // Site Management
    createSite: adminProcedure
      .input(z.object({
        centreId: z.number(),
        siteNumber: z.string(),
        description: z.string().optional(),
        size: z.string().optional(),
        maxTables: z.number().optional(),
        powerAvailable: z.string().optional(),
        restrictions: z.string().optional(),
        dailyRate: z.string(),
        weeklyRate: z.string(),
        instantBooking: z.boolean().optional(),
      }))
      .mutation(async ({ input }) => {
        return await db.createSite(input);
      }),

    updateSite: adminProcedure
      .input(z.object({
        id: z.number(),
        siteNumber: z.string().optional(),
        description: z.string().optional(),
        size: z.string().optional(),
        maxTables: z.number().nullish(),
        powerAvailable: z.string().optional(),
        restrictions: z.string().optional(),
        dailyRate: z.string().optional(),
        weeklyRate: z.string().optional(),
        weekendRate: z.string().nullish(),
        instantBooking: z.boolean().optional(),
        imageUrl1: z.string().nullish(),
        imageUrl2: z.string().nullish(),
        imageUrl3: z.string().nullish(),
        imageUrl4: z.string().nullish(),
      }))
      .mutation(async ({ input }) => {
        const { id, dailyRate, weeklyRate, weekendRate, ...rest } = input;
        const data: any = { ...rest };
        
        // Map frontend field names to database column names
        // Handle empty strings as null for decimal fields
        if (dailyRate !== undefined) data.pricePerDay = dailyRate || null;
        if (weeklyRate !== undefined) data.pricePerWeek = weeklyRate || null;
        if (weekendRate !== undefined) data.weekendPricePerDay = weekendRate || null;
        
        console.log('[updateSite] Updating site:', { id, data });
        try {
          const result = await db.updateSite(id, data);
          console.log('[updateSite] Success:', result);
          return result;
        } catch (error: any) {
          console.error('[updateSite] Error:', error.message, error.stack);
          throw error;
        }
      }),

    getSystemConfig: protectedProcedure
      .query(async () => {
        return await getSystemConfigDb();
      }),

    updateSystemConfig: adminProcedure
      .input(z.object({
        imageQuality: z.number().min(50).max(100),
        imageMaxWidth: z.number().min(800).max(2400),
        imageMaxHeight: z.number().min(600).max(1600),
      }))
      .mutation(async ({ input }) => {
        await updateSystemConfigDb(input);
        return { success: true };
      }),

    // Image Analytics
    trackImageView: publicProcedure
      .input(z.object({
        siteId: z.number(),
        imageSlot: z.number().min(1).max(4),
      }))
      .mutation(async ({ input }) => {
        await trackImageView(input.siteId, input.imageSlot);
        return { success: true };
      }),

    trackImageClick: publicProcedure
      .input(z.object({
        siteId: z.number(),
        imageSlot: z.number().min(1).max(4),
      }))
      .mutation(async ({ input }) => {
        await trackImageClick(input.siteId, input.imageSlot);
        return { success: true };
      }),

    getTopPerformingImages: protectedProcedure
      .input(z.object({
        limit: z.number().optional().default(10),
      }))
      .query(async ({ input }) => {
        return await getTopPerformingImages(input.limit);
      }),

    getImageAnalyticsBySite: protectedProcedure
      .input(z.object({
        siteId: z.number(),
      }))
      .query(async ({ input }) => {
        return await getImageAnalyticsBySite(input.siteId);
      }),

    uploadSiteImage: adminProcedure
      .input(z.object({
        siteId: z.number(),
        imageSlot: z.number().min(1).max(4),
        base64Image: z.string(),
      }))
      .mutation(async ({ input }) => {
        const { processSiteImage } = await import('./imageProcessing');
        const { url } = await processSiteImage(
          input.base64Image,
          input.siteId,
          input.imageSlot
        );
        
        // Update the site with the new image URL
        await db.updateSite(input.siteId, {
          [`imageUrl${input.imageSlot}`]: url,
        } as any);
        
        return { url };
      }),

    deleteSite: adminProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        return await db.deleteSite(input.id);
      }),

    // Map Management
    uploadCentreMap: adminProcedure
      .input(z.object({
        centreId: z.number(),
        imageData: z.string(), // base64 encoded image
        fileName: z.string(),
      }))
      .mutation(async ({ input }) => {
        return await db.uploadCentreMap(input.centreId, input.imageData, input.fileName);
      }),

    saveSiteMarkers: adminProcedure
      .input(z.object({
        centreId: z.number(),
        markers: z.array(z.object({
          siteId: z.number(),
          x: z.number().min(0).max(100),
          y: z.number().min(0).max(100),
        })),
      }))
      .mutation(async ({ input }) => {
        return await db.saveSiteMarkers(input.markers);
      }),

    resetSiteMarker: adminProcedure
      .input(z.object({
        siteId: z.number(),
      }))
      .mutation(async ({ input }) => {
        return await db.resetSiteMarker(input.siteId);
      }),

    // Floor Level Management
    getFloorLevels: adminProcedure
      .input(z.object({ centreId: z.number() }))
      .query(async ({ input }) => {
        return await db.getFloorLevelsByCentre(input.centreId, true); // Include hidden floors for admin
      }),

    createFloorLevel: adminProcedure
      .input(z.object({
        centreId: z.number(),
        levelName: z.string(),
        levelNumber: z.string(), // e.g., "G", "L1", "M", "Upper"
        displayOrder: z.number(),
      }))
      .mutation(async ({ input }) => {
        return await db.createFloorLevel(input);
      }),

    deleteFloorLevel: adminProcedure
      .input(z.object({ floorLevelId: z.number() }))
      .mutation(async ({ input }) => {
        return await db.deleteFloorLevel(input.floorLevelId);
      }),

    hideFloorLevel: adminProcedure
      .input(z.object({ floorLevelId: z.number() }))
      .mutation(async ({ input }) => {
        return await db.hideFloorLevel(input.floorLevelId);
      }),

    unhideFloorLevel: adminProcedure
      .input(z.object({ floorLevelId: z.number() }))
      .mutation(async ({ input }) => {
        return await db.unhideFloorLevel(input.floorLevelId);
      }),

    uploadFloorLevelMap: adminProcedure
      .input(z.object({
        floorLevelId: z.number(),
        imageData: z.string(),
        fileName: z.string(),
      }))
      .mutation(async ({ input }) => {
        return await db.uploadFloorLevelMap(input.floorLevelId, input.imageData, input.fileName);
      }),

    getSitesByFloorLevel: adminProcedure
      .input(z.object({ floorLevelId: z.number() }))
      .query(async ({ input }) => {
        return await db.getSitesByFloorLevel(input.floorLevelId);
      }),

    updateSiteFloorAssignment: adminProcedure
      .input(z.object({
        assignments: z.array(z.object({
          siteId: z.number(),
          floorLevelId: z.number().nullable()
        }))
      }))
      .mutation(async ({ input }) => {
        return await db.updateSiteFloorAssignments(input.assignments);
      }),

    // Seasonal Pricing Management
    getSeasonalRatesBySite: adminProcedure
      .input(z.object({ siteId: z.number() }))
      .query(async ({ input }) => {
        return await getSeasonalRatesBySiteId(input.siteId);
      }),

    createSeasonalRate: adminProcedure
      .input(z.object({
        siteId: z.number(),
        name: z.string(),
        startDate: z.string(),
        endDate: z.string(),
        weekdayRate: z.number().optional(),
        weekendRate: z.number().optional(),
        weeklyRate: z.number().optional(),
      }))
      .mutation(async ({ input }) => {
        return await createSeasonalRate(input);
      }),

    updateSeasonalRate: adminProcedure
      .input(z.object({
        id: z.number(),
        name: z.string().optional(),
        startDate: z.string().optional(),
        endDate: z.string().optional(),
        weekdayRate: z.number().optional(),
        weekendRate: z.number().optional(),
        weeklyRate: z.number().optional(),
      }))
      .mutation(async ({ input }) => {
        const { id, ...data } = input;
        return await updateSeasonalRate(id, data);
      }),

    deleteSeasonalRate: adminProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        return await deleteSeasonalRate(input.id);
      }),

    getOwners: adminProcedure
      .query(async () => {
        return await db.getOwners();
      }),

    getAllCentres: adminProcedure
      .query(async () => {
        const centres = await db.getShoppingCentres();
        // Get sites for each centre to calculate max tables needed
        const centresWithSites = await Promise.all(
          centres.map(async (centre) => {
            const sites = await db.getSitesByCentreId(centre.id);
            return { ...centre, sites };
          })
        );
        return centresWithSites;
      }),

    updateCentreEquipment: adminProcedure
      .input(z.object({
        centreId: z.number(),
        totalTablesAvailable: z.number().min(0),
        totalChairsAvailable: z.number().min(0),
      }))
      .mutation(async ({ input }) => {
        return await db.updateShoppingCentre(input.centreId, {
          totalTablesAvailable: input.totalTablesAvailable,
          totalChairsAvailable: input.totalChairsAvailable,
        });
      }),

    // Booking Approval Management
    getPendingApprovals: adminProcedure
      .query(async () => {
        const pendingBookings = await db.getBookingsByStatus('pending');
        
        // Get additional details for each booking
        const bookingsWithDetails = await Promise.all(
          pendingBookings
            .filter(b => b.requiresApproval)
            .map(async (booking) => {
              const site = await db.getSiteById(booking.siteId);
              const centre = site ? await db.getShoppingCentreById(site.centreId) : null;
              const customer = await db.getUserById(booking.customerId);
              const usageType = booking.usageTypeId ? await db.getUsageTypeById(booking.usageTypeId) : null;
              
              // Determine specific approval reason
              const customerProfile = await db.getCustomerProfileByUserId(booking.customerId);
              let approvalReason = 'Manual approval required';
              let insuranceExpired = false;
              const reasons: string[] = [];
              
              // Check insurance expiry
              if (customerProfile?.insuranceExpiry) {
                const insuranceExpiryDate = new Date(customerProfile.insuranceExpiry);
                const bookingEndDate = new Date(booking.endDate);
                
                if (insuranceExpiryDate < bookingEndDate) {
                  reasons.push('Insurance expired before booking end date');
                  insuranceExpired = true;
                }
              }
              
              // Check insurance coverage amount
              if (customerProfile?.insuranceAmount) {
                const coverageAmount = parseFloat(customerProfile.insuranceAmount);
                const requiredAmount = 20000000; // $20M minimum
                
                if (coverageAmount < requiredAmount) {
                  reasons.push(`Insufficient insurance coverage ($${(coverageAmount / 1000000).toFixed(1)}M, requires $20M)`);
                }
              }
              
              // Check if custom category text was provided
              if (booking.additionalCategoryText && booking.additionalCategoryText.trim().length > 0) {
                reasons.push('Custom usage category details provided');
              }
              
              // Check if usage category is not approved for site
              if (booking.usageCategoryId) {
                const { isCategoryApprovedForSite, getApprovedCategoriesForSite } = await import('./usageCategoriesDb');
                const approvedCategories = await getApprovedCategoriesForSite(booking.siteId);
                
                if (approvedCategories.length > 0) {
                  const isApproved = await isCategoryApprovedForSite(booking.siteId, booking.usageCategoryId);
                  
                  if (!isApproved) {
                    const { getAllUsageCategories } = await import('./usageCategoriesDb');
                    const allCategories = await getAllUsageCategories();
                    const category = allCategories.find(c => c.id === booking.usageCategoryId);
                    reasons.push(`Usage category "${category?.name || 'Unknown'}" not approved for this site`);
                  } else {
                    // Check for overlapping bookings from OTHER customers (category exclusivity)
                    const { getDb } = await import('./db');
                    const { bookings: bookingsTable, sites: sitesTable } = await import('../drizzle/schema');
                    const { eq, and, ne, or, lte, gte } = await import('drizzle-orm');
                    const dbInstance = await getDb();
                    
                    if (dbInstance && site) {
                      const overlappingBookings = await dbInstance.select()
                        .from(bookingsTable)
                        .innerJoin(sitesTable, eq(bookingsTable.siteId, sitesTable.id))
                        .where(and(
                          ne(bookingsTable.customerId, booking.customerId), // DIFFERENT customer
                          eq(bookingsTable.usageCategoryId, booking.usageCategoryId), // SAME category
                          eq(sitesTable.centreId, site.centreId), // SAME centre
                          ne(bookingsTable.id, booking.id), // DIFFERENT booking
                          or(
                            eq(bookingsTable.status, 'pending'),
                            eq(bookingsTable.status, 'confirmed')
                          ), // Only active bookings
                          // Date overlap check
                          lte(bookingsTable.startDate, booking.endDate),
                          gte(bookingsTable.endDate, booking.startDate)
                        ));
                      
                      if (overlappingBookings.length > 0) {
                        reasons.push('Category conflict: another customer has overlapping booking with same category at this centre');
                      }
                    }
                  }
                }
              }
              
              // Check if site requires manual approval (no instant booking)
              if (!site?.instantBooking) {
                reasons.push('Site requires manual approval for all bookings');
              }
              
              // Check legacy custom usage
              if (booking.customUsage) {
                reasons.push('Custom usage type specified');
              }
              
              // Combine all reasons or use default
              if (reasons.length > 0) {
                approvalReason = reasons.join('; ');
              }
              
              return {
                ...booking,
                centreName: centre?.name || 'Unknown Centre',
                siteNumber: site?.siteNumber || 'Unknown',
                siteDescription: site?.description,
                customerName: customer?.name || 'Unknown Customer',
                customerEmail: customer?.email,
                usageTypeName: usageType?.name,
                approvalReason,
                insuranceExpired,
              };
            })
        );
        
        return bookingsWithDetails;
      }),

    approveBooking: adminProcedure
      .input(z.object({ bookingId: z.number() }))
      .mutation(async ({ ctx, input }) => {
        await db.approveBooking(input.bookingId, ctx.user.id);
        
        // Get booking details for notification
        const booking = await db.getBookingById(input.bookingId);
        const site = booking ? await db.getSiteById(booking.siteId) : null;
        const centre = site ? await db.getShoppingCentreById(site.centreId) : null;
        
        // Notify owner
        await notifyOwner({
          title: 'Booking Approved',
          content: `Booking #${booking?.bookingNumber} at ${centre?.name} - Site ${site?.siteNumber} has been approved.`,
        });
        
        // TODO: Send confirmation email to customer
        
        return { success: true };
      }),

    rejectBooking: adminProcedure
      .input(z.object({ bookingId: z.number(), reason: z.string().optional() }))
      .mutation(async ({ input }) => {
        await db.rejectBooking(input.bookingId, input.reason || "No reason provided");
        
        // Get booking details for notification
        const booking = await db.getBookingById(input.bookingId);
        const site = booking ? await db.getSiteById(booking.siteId) : null;
        const centre = site ? await db.getShoppingCentreById(site.centreId) : null;
        
        // Notify owner
        await notifyOwner({
          title: 'Booking Rejected',
          content: `Booking #${booking?.bookingNumber} at ${centre?.name} - Site ${site?.siteNumber} has been rejected.`,
        });
        
        // TODO: Send rejection email to customer with reason
        
        return { success: true };
      }),

    bulkCreateSeasonalRates: adminProcedure
      .input(z.object({
        centreIds: z.array(z.number()),
        name: z.string(),
        startDate: z.string(),
        endDate: z.string(),
        percentageIncrease: z.number(),
      }))
      .mutation(async ({ input }) => {
        const { centreIds, name, startDate, endDate, percentageIncrease } = input;
        
        // Get all sites for the selected centres
        const allSites = [];
        for (const centreId of centreIds) {
          const sites = await db.getSitesByCentreId(centreId);
          allSites.push(...sites);
        }

        // Create seasonal rates for each site
        let created = 0;
        for (const site of allSites) {
          // Calculate increased rates
          const multiplier = 1 + (percentageIncrease / 100);
          const baseWeekdayRate = site.pricePerDay ? parseFloat(site.pricePerDay) : 0;
          const baseWeekendRate = site.weekendPricePerDay ? parseFloat(site.weekendPricePerDay) : 0;
          
          const weekdayRate = baseWeekdayRate > 0 ? Math.round(baseWeekdayRate * multiplier * 100) / 100 : undefined;
          // If weekend rate is $0 or null, use weekday rate as base for percentage increase
          const weekendRate = baseWeekendRate > 0 
            ? Math.round(baseWeekendRate * multiplier * 100) / 100 
            : (baseWeekdayRate > 0 ? Math.round(baseWeekdayRate * multiplier * 100) / 100 : undefined);
          const weeklyRate = site.pricePerWeek ? Math.round(parseFloat(site.pricePerWeek) * multiplier * 100) / 100 : undefined;

          await createSeasonalRate({
            siteId: site.id,
            name,
            startDate,
            endDate,
            weekdayRate,
            weekendRate,
            weeklyRate,
          });
          created++;
        }

        return { created, totalSites: allSites.length };
      }),

    // Invoice Payment Management
    searchInvoiceBookings: adminProcedure
      .input(z.object({ query: z.string() }))
      .query(async ({ input }) => {
        return await db.searchInvoiceBookings(input.query);
      }),

    recordPayment: adminProcedure
      .input(z.object({ bookingId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        return await db.recordPayment(input.bookingId, ctx.user.name || 'Admin');
      }),

    triggerPaymentReminders: adminProcedure
      .mutation(async () => {
        const { sendPaymentReminders } = await import('./paymentReminders');
        return await sendPaymentReminders();
      }),

    // Invoice Dashboard
    getInvoiceStats: adminProcedure
      .query(async () => {
        const { getInvoiceStats } = await import('./invoiceDashboardDb');
        return await getInvoiceStats();
      }),

    getInvoiceList: adminProcedure
      .input(z.object({
        filter: z.enum(['all', 'outstanding', 'overdue', 'paid']).default('all'),
      }))
      .query(async ({ input }) => {
        const { getInvoiceList } = await import('./invoiceDashboardDb');
        return await getInvoiceList(input.filter);
      }),

    getPaymentHistory: adminProcedure
      .input(z.object({
        searchTerm: z.string().optional(),
      }))
      .query(async ({ input }) => {
        const { getPaymentHistory } = await import('./invoiceDashboardDb');
        return await getPaymentHistory(input.searchTerm);
      }),

    // User Registration
    registerUser: adminProcedure
      .input(z.object({
        email: z.string().email(),
        name: z.string(),
        password: z.string().min(8),
        role: z.enum([
          'customer',
          'owner_centre_manager',
          'owner_marketing_manager',
          'owner_regional_admin',
          'owner_state_admin',
          'owner_super_admin',
          'mega_state_admin',
          'mega_admin'
        ]).default('customer'),
        canPayByInvoice: z.boolean().default(false),
        // Company details
        companyName: z.string().optional(),
        companyWebsite: z.string().optional(),
        abn: z.string().optional(),
        address: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        postcode: z.string().optional(),
        productService: z.string().optional(),
        // Insurance details
        insuranceCompany: z.string().optional(),
        insurancePolicyNo: z.string().optional(),
        insuranceAmount: z.string().optional(),
        insuranceExpiryDate: z.string().optional(),
      }))
      .mutation(async ({ input }) => {
        // Check if user already exists
        const existingUser = await db.getUserByEmail(input.email);
        if (existingUser) {
          throw new TRPCError({ code: 'CONFLICT', message: 'User with this email already exists' });
        }

        // Create user with hashed password
        const bcrypt = await import('bcryptjs');
        const hashedPassword = await bcrypt.hash(input.password, 10);

        const { getDb } = await import('./db');
        const { users } = await import('../drizzle/schema');
        const dbInstance = await getDb();
        
        if (!dbInstance) {
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Database connection failed' });
        }

        // Generate a unique openId for the user
        const openId = `manual_${Date.now()}_${Math.random().toString(36).substring(7)}`;

        const [newUser] = await dbInstance.insert(users).values({
          openId,
          email: input.email,
          name: input.name,
          role: input.role,
          canPayByInvoice: input.canPayByInvoice,
        });

        // Create customer profile if company or insurance details provided
        if (input.companyName || input.insuranceCompany) {
          const { customerProfiles } = await import('../drizzle/schema');
          await dbInstance.insert(customerProfiles).values({
            userId: newUser.insertId,
            companyName: input.companyName || null,
            website: input.companyWebsite || null,
            abn: input.abn || null,
            streetAddress: input.address || null,
            city: input.city || null,
            state: input.state || null,
            postcode: input.postcode || null,
            productCategory: input.productService || null,
            insuranceCompany: input.insuranceCompany || null,
            insurancePolicyNo: input.insurancePolicyNo || null,
            insuranceAmount: input.insuranceAmount || null,
            insuranceExpiry: input.insuranceExpiryDate ? new Date(input.insuranceExpiryDate) : null,
          });
        }

        return { success: true, message: 'User registered successfully' };
      }),

    // Update User
    updateUser: adminProcedure
      .input(z.object({
        userId: z.number(),
        email: z.string().email().optional(),
        name: z.string().optional(),
        role: z.enum([
          'customer',
          'owner_centre_manager',
          'owner_marketing_manager',
          'owner_regional_admin',
          'owner_state_admin',
          'owner_super_admin',
          'mega_state_admin',
          'mega_admin'
        ]).optional(),
        assignedState: z.string().nullable().optional(),
        canPayByInvoice: z.boolean().optional(),
        // Company details
        companyName: z.string().optional(),
        website: z.string().optional(),
        abn: z.string().optional(),
        streetAddress: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        postcode: z.string().optional(),
        productCategory: z.string().optional(),
        productDetails: z.string().optional(),
        // Insurance details
        insuranceCompany: z.string().optional(),
        insurancePolicyNo: z.string().optional(),
        insuranceAmount: z.string().optional(),
        insuranceExpiry: z.string().optional(),
        insuranceDocumentUrl: z.string().optional(),
      }))
      .mutation(async ({ input }) => {
        const { getDb } = await import('./db');
        const { users, customerProfiles } = await import('../drizzle/schema');
        const { eq } = await import('drizzle-orm');
        const dbInstance = await getDb();
        
        if (!dbInstance) {
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Database connection failed' });
        }

        // Update user basic info
        const userUpdates: any = {};
        if (input.email) userUpdates.email = input.email;
        if (input.name) userUpdates.name = input.name;
        if (input.role) userUpdates.role = input.role;
        if (input.assignedState !== undefined) userUpdates.assignedState = input.assignedState || null;
        if (input.canPayByInvoice !== undefined) userUpdates.canPayByInvoice = input.canPayByInvoice;

        if (Object.keys(userUpdates).length > 0) {
          await dbInstance.update(users).set(userUpdates).where(eq(users.id, input.userId));
        }

        // Update or create customer profile
        const profileUpdates: any = {};
        if (input.companyName !== undefined) profileUpdates.companyName = input.companyName || null;
        if (input.website !== undefined) profileUpdates.website = input.website || null;
        if (input.abn !== undefined) profileUpdates.abn = input.abn || null;
        if (input.streetAddress !== undefined) profileUpdates.streetAddress = input.streetAddress || null;
        if (input.city !== undefined) profileUpdates.city = input.city || null;
        if (input.state !== undefined) profileUpdates.state = input.state || null;
        if (input.postcode !== undefined) profileUpdates.postcode = input.postcode || null;
        if (input.productCategory !== undefined) profileUpdates.productCategory = input.productCategory || null;
        if (input.productDetails !== undefined) profileUpdates.productDetails = input.productDetails || null;
        if (input.insuranceCompany !== undefined) profileUpdates.insuranceCompany = input.insuranceCompany || null;
        if (input.insurancePolicyNo !== undefined) profileUpdates.insurancePolicyNo = input.insurancePolicyNo || null;
        if (input.insuranceAmount !== undefined) profileUpdates.insuranceAmount = input.insuranceAmount || null;
        if (input.insuranceExpiry !== undefined) profileUpdates.insuranceExpiry = input.insuranceExpiry ? new Date(input.insuranceExpiry) : null;
        if (input.insuranceDocumentUrl !== undefined) profileUpdates.insuranceDocumentUrl = input.insuranceDocumentUrl || null;

        if (Object.keys(profileUpdates).length > 0) {
          // Check if profile exists
          const existingProfile = await dbInstance.select().from(customerProfiles).where(eq(customerProfiles.userId, input.userId)).limit(1);
          
          if (existingProfile.length > 0) {
            // Update existing profile
            await dbInstance.update(customerProfiles).set(profileUpdates).where(eq(customerProfiles.userId, input.userId));
          } else {
            // Create new profile
            await dbInstance.insert(customerProfiles).values({
              userId: input.userId,
              ...profileUpdates,
            });
          }
        }

        return { success: true, message: 'User updated successfully' };
      }),
  }),

  // Usage Categories
  usageCategories: router({
    list: publicProcedure.query(async () => {
      return await getAllUsageCategories();
    }),
    
    getApprovedForSite: publicProcedure
      .input(z.object({ siteId: z.number() }))
      .query(async ({ input }) => {
        return await getApprovedCategoriesForSite(input.siteId);
      }),
    
    getSitesWithCategories: adminProcedure
      .input(z.object({ centreId: z.number() }))
      .query(async ({ input }) => {
        return await getSitesWithCategoriesForCentre(input.centreId);
      }),
    
    setApprovedCategories: adminProcedure
      .input(z.object({
        siteId: z.number(),
        categoryIds: z.array(z.number()),
      }))
      .mutation(async ({ input }) => {
        await setApprovedCategoriesForSite(input.siteId, input.categoryIds);
        return { success: true };
      }),
    
    createCategory: adminProcedure
      .input(z.object({
        name: z.string().min(1),
        isFree: z.boolean(),
        displayOrder: z.number().int().positive(),
      }))
      .mutation(async ({ input }) => {
        const { createUsageCategory } = await import("./usageCategoriesDb");
        const categoryId = await createUsageCategory(input.name, input.isFree, input.displayOrder);
        return { success: true, categoryId };
      }),
    
    applyToAllSites: adminProcedure
      .input(z.object({
        centreId: z.number(),
        categoryIds: z.array(z.number()),
      }))
      .mutation(async ({ input }) => {
        const { applyApprovalsToAllSitesInCentre } = await import("./usageCategoriesDb");
        const sitesUpdated = await applyApprovalsToAllSitesInCentre(input.centreId, input.categoryIds);
        return { success: true, sitesUpdated };
      }),
  }),

  // System Configuration
  users: router({
    list: adminProcedure.query(async () => {
      return await db.getAllUsers();
    }),

    updateInvoiceFlag: adminProcedure
      .input(z.object({
        userId: z.number(),
        canPayByInvoice: z.boolean(),
      }))
      .mutation(async ({ input, ctx }) => {
        // Only mega_admin and owner_super_admin can modify invoice payment flag
        if (ctx.user.role !== "mega_admin" && ctx.user.role !== "owner_super_admin") {
          throw new TRPCError({ code: "FORBIDDEN", message: "Only SuperAdmin can modify invoice payment settings" });
        }
        await db.updateUserInvoiceFlag(input.userId, input.canPayByInvoice);
        return { success: true };
      }),
  }),

  searchAnalytics: router({
    getSummary: adminProcedure
      .input(z.object({
        startDate: z.date().optional(),
        endDate: z.date().optional(),
      }))
      .query(async ({ input }) => {
        const { getSearchAnalyticsSummary } = await import("./searchAnalyticsDb");
        return await getSearchAnalyticsSummary(input);
      }),

    getPopularSearches: adminProcedure
      .input(z.object({
        limit: z.number().optional().default(10),
        startDate: z.date().optional(),
        endDate: z.date().optional(),
      }))
      .query(async ({ input }) => {
        const { getPopularSearches } = await import("./searchAnalyticsDb");
        return await getPopularSearches(input);
      }),

    getFailedSearches: adminProcedure
      .input(z.object({
        limit: z.number().optional().default(10),
        startDate: z.date().optional(),
        endDate: z.date().optional(),
      }))
      .query(async ({ input }) => {
        const { getFailedSearches } = await import("./searchAnalyticsDb");
        return await getFailedSearches(input);
      }),

    getSuggestionClickThroughRate: adminProcedure
      .input(z.object({
        startDate: z.date().optional(),
        endDate: z.date().optional(),
      }))
      .query(async ({ input }) => {
        const { getSuggestionClickThroughRate } = await import("./searchAnalyticsDb");
        return await getSuggestionClickThroughRate(input);
      }),
  }),

  systemConfig: router({
    getGstPercentage: publicProcedure.query(async () => {
      const value = await getConfigValue("gst_percentage");
      return { gstPercentage: value ? parseFloat(value) : 10.0 };
    }),

    setGstPercentage: adminProcedure
      .input(z.object({ gstPercentage: z.number().min(0).max(100) }))
      .mutation(async ({ input, ctx }) => {
        // Only mega_admin and owner_super_admin can change GST
        if (ctx.user.role !== "mega_admin" && ctx.user.role !== "owner_super_admin") {
          throw new TRPCError({ code: "FORBIDDEN", message: "Only SuperAdmin can change GST percentage" });
        }
        await setConfigValue("gst_percentage", input.gstPercentage.toString());
        return { success: true, gstPercentage: input.gstPercentage };
      }),
  }),

  // Portfolio Dashboard
  dashboard: router({
    getMetrics: adminProcedure
      .input(z.object({
        month: z.number().min(1).max(12),
        year: z.number(),
        state: z.string().optional(), // For National Admin filtering by state
        financialYear: z.number().optional(), // For YTD calculations based on selected FY
      }))
      .query(async ({ input, ctx }) => {
        const { getPermittedSiteIds, getYTDMetrics, getMonthlyMetrics, getBudgetMetrics, getPendingApprovalsCount } = await import('./dashboardDb');
        
        // Determine which state to filter by
        let filterState: string | null = null;
        if (ctx.user.role === 'mega_state_admin' || ctx.user.role === 'owner_state_admin') {
          // State admins can only see their assigned state
          filterState = ctx.user.assignedState || null;
        } else if (input.state && input.state !== 'all') {
          // National admins can filter by any state
          filterState = input.state;
        }
        
        // Get permitted site IDs based on role and state filter
        const siteIds = await getPermittedSiteIds(ctx.user.role, filterState);
        
        if (siteIds.length === 0) {
          throw new TRPCError({ code: 'FORBIDDEN', message: 'No dashboard access for your role' });
        }
        
        // Get current year metrics - use financialYear for YTD if provided
        const ytdMetrics = await getYTDMetrics(siteIds, input.year, input.financialYear);
        const monthMetrics = await getMonthlyMetrics(siteIds, input.month, input.year);
        
        // Get last year metrics for comparison
        const lastYear = input.year - 1;
        const lastFY = input.financialYear ? input.financialYear - 1 : undefined;
        const ytdMetricsLastYear = await getYTDMetrics(siteIds, lastYear, lastFY);
        const monthMetricsLastYear = await getMonthlyMetrics(siteIds, input.month, lastYear);
        
        // Get budget data
        const budgetMetrics = await getBudgetMetrics(siteIds, input.month, input.year);
        
        // Get pending approvals count
        const pendingApprovalsCount = await getPendingApprovalsCount(siteIds);
        
        return {
          thisYear: {
            ytd: ytdMetrics,
            month: monthMetrics,
          },
          lastYear: {
            ytd: ytdMetricsLastYear,
            month: monthMetricsLastYear,
          },
          budget: budgetMetrics,
          pendingApprovalsCount,
          lastUpdated: new Date(),
        };
      }),
    
    getAvailableStates: adminProcedure.query(async () => {
      const { getAvailableStates } = await import('./dashboardDb');
      return await getAvailableStates();
    }),

    getFYBudgetMetrics: adminProcedure
      .input(z.object({
        financialYear: z.number(),
        state: z.string().optional(),
      }))
      .query(async ({ input, ctx }) => {
        const { getFYBudgetMetrics, getPermittedCentreIds } = await import('./fyBudgetDb');
        
        // Determine which state to filter by
        let filterState: string | null = null;
        if (ctx.user.role === 'mega_state_admin' || ctx.user.role === 'owner_state_admin') {
          filterState = ctx.user.assignedState || null;
        } else if (input.state && input.state !== 'all') {
          filterState = input.state;
        }
        
        // Get permitted centre IDs
        const centreIds = await getPermittedCentreIds(ctx.user.role, filterState);
        
        // Get FY budget metrics
        return await getFYBudgetMetrics(centreIds, input.financialYear);
      }),

    getSiteBreakdown: adminProcedure
      .input(z.object({
        year: z.number(),
        breakdownType: z.enum(['annual', 'ytd']),
        state: z.string().optional(),
      }))
      .query(async ({ input, ctx }) => {
        const { getSiteBreakdown } = await import('./dashboardDb');
        
        // Determine which state to filter by
        let filterState: string | undefined = input.state;
        if (ctx.user.role === 'mega_state_admin' || ctx.user.role === 'owner_state_admin') {
          // State admins can only see their assigned state
          filterState = ctx.user.assignedState || undefined;
        }
        
        return await getSiteBreakdown(
          ctx.user.role,
          ctx.user.assignedState || null,
          input.year,
          input.breakdownType,
          filterState
        );
      }),

    getCentreBreakdown: adminProcedure
      .input(z.object({
        financialYear: z.number(),
        breakdownType: z.enum(['annual', 'ytd']),
        state: z.string().optional(),
      }))
      .query(async ({ input, ctx }) => {
        const { getCentreBreakdown } = await import('./fyBudgetDb');
        
        // Determine which state to filter by
        let filterState: string | undefined = input.state;
        if (ctx.user.role === 'mega_state_admin' || ctx.user.role === 'owner_state_admin') {
          // State admins can only see their assigned state
          filterState = ctx.user.assignedState || undefined;
        }
        
        return await getCentreBreakdown(
          ctx.user.role,
          ctx.user.assignedState || null,
          input.financialYear,
          input.breakdownType,
          filterState
        );
      }),

    exportBudgetReport: adminProcedure
      .input(z.object({
        financialYear: z.number(),
        state: z.string().optional(),
        format: z.enum(['pdf', 'excel']),
      }))
      .mutation(async ({ input, ctx }) => {
        const { getCentreBreakdown, getFyPercentages, getCentreBudgetsForYear } = await import('./fyBudgetDb');
        const { getYTDMetrics } = await import('./dashboardDb');
        
        // Determine which state to filter by
        let filterState: string | undefined = input.state;
        if (ctx.user.role === 'mega_state_admin' || ctx.user.role === 'owner_state_admin') {
          filterState = ctx.user.assignedState || undefined;
        }
        
        // Get data for report
        const centreBreakdown = await getCentreBreakdown(
          ctx.user.role,
          ctx.user.assignedState || null,
          input.financialYear,
          'annual',
          filterState
        );
        
        const percentages = await getFyPercentages(input.financialYear);
        const centreBudgetsData = await getCentreBudgetsForYear(input.financialYear);
        
        // Calculate totals
        const totalBudget = centreBreakdown.reduce((sum, c) => sum + c.budget, 0);
        const totalActual = centreBreakdown.reduce((sum, c) => sum + c.actual, 0);
        const totalVariance = totalActual - totalBudget;
        const overallPercentage = totalBudget > 0 ? (totalActual / totalBudget) * 100 : 0;
        
        if (input.format === 'excel') {
          // Generate Excel file
          const ExcelJS = await import('exceljs');
          const workbook = new ExcelJS.Workbook();
          
          // Summary Sheet
          const summarySheet = workbook.addWorksheet('Summary');
          summarySheet.columns = [
            { header: 'Metric', key: 'metric', width: 30 },
            { header: 'Value', key: 'value', width: 20 },
          ];
          summarySheet.addRow({ metric: 'Financial Year', value: `FY ${input.financialYear - 1}-${input.financialYear}` });
          summarySheet.addRow({ metric: 'Report Generated', value: new Date().toLocaleString() });
          summarySheet.addRow({ metric: 'State Filter', value: filterState || 'All States' });
          summarySheet.addRow({ metric: '', value: '' });
          summarySheet.addRow({ metric: 'Total Annual Budget', value: `$${totalBudget.toLocaleString()}` });
          summarySheet.addRow({ metric: 'Total Actual Revenue', value: `$${totalActual.toLocaleString()}` });
          summarySheet.addRow({ metric: 'Total Variance', value: `$${totalVariance.toLocaleString()}` });
          summarySheet.addRow({ metric: 'Overall Achievement', value: `${overallPercentage.toFixed(1)}%` });
          
          // Centre Breakdown Sheet
          const breakdownSheet = workbook.addWorksheet('Centre Breakdown');
          breakdownSheet.columns = [
            { header: 'Centre', key: 'centre', width: 35 },
            { header: 'State', key: 'state', width: 10 },
            { header: 'Annual Budget', key: 'budget', width: 18 },
            { header: 'Actual Revenue', key: 'actual', width: 18 },
            { header: 'Variance', key: 'variance', width: 18 },
            { header: '% Achieved', key: 'percentage', width: 15 },
          ];
          
          centreBreakdown.forEach(centre => {
            breakdownSheet.addRow({
              centre: centre.centreName,
              state: centre.centreState,
              budget: `$${centre.budget.toLocaleString()}`,
              actual: `$${centre.actual.toLocaleString()}`,
              variance: `$${centre.variance.toLocaleString()}`,
              percentage: `${centre.percentAchieved.toFixed(1)}%`,
            });
          });
          
          // Monthly Percentages Sheet
          const percentagesSheet = workbook.addWorksheet('Monthly Percentages');
          percentagesSheet.columns = [
            { header: 'Month', key: 'month', width: 15 },
            { header: 'Percentage', key: 'percentage', width: 15 },
          ];
          const monthNames = ['July', 'August', 'September', 'October', 'November', 'December', 'January', 'February', 'March', 'April', 'May', 'June'];
          if (percentages) {
            const pctValues = [percentages.july, percentages.august, percentages.september, percentages.october, percentages.november, percentages.december, percentages.january, percentages.february, percentages.march, percentages.april, percentages.may, percentages.june];
            monthNames.forEach((month, i) => {
              percentagesSheet.addRow({ month, percentage: `${pctValues[i]}%` });
            });
          }
          
          // Generate buffer
          const buffer = await workbook.xlsx.writeBuffer();
          return {
            data: Buffer.from(buffer as ArrayBuffer).toString('base64'),
            filename: `Budget_Report_FY${input.financialYear - 1}-${input.financialYear}.xlsx`,
            mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          };
        } else {
          // Generate PDF using HTML template
          const html = `
            <!DOCTYPE html>
            <html>
            <head>
              <style>
                body { font-family: Arial, sans-serif; padding: 40px; }
                h1 { color: #1e40af; margin-bottom: 5px; }
                h2 { color: #374151; margin-top: 30px; }
                .subtitle { color: #6b7280; margin-bottom: 30px; }
                table { width: 100%; border-collapse: collapse; margin-top: 15px; }
                th, td { border: 1px solid #e5e7eb; padding: 10px; text-align: left; }
                th { background-color: #f3f4f6; font-weight: 600; }
                .positive { color: #059669; }
                .negative { color: #dc2626; }
                .summary-box { background: #f0f9ff; padding: 20px; border-radius: 8px; margin-bottom: 30px; }
                .summary-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; }
                .summary-item { text-align: center; }
                .summary-value { font-size: 24px; font-weight: bold; color: #1e40af; }
                .summary-label { color: #6b7280; font-size: 14px; }
              </style>
            </head>
            <body>
              <h1>Budget vs Actual Report</h1>
              <p class="subtitle">Financial Year ${input.financialYear - 1}-${input.financialYear} | ${filterState || 'All States'} | Generated: ${new Date().toLocaleDateString()}</p>
              
              <div class="summary-box">
                <div class="summary-grid">
                  <div class="summary-item">
                    <div class="summary-value">$${totalBudget.toLocaleString()}</div>
                    <div class="summary-label">Annual Budget</div>
                  </div>
                  <div class="summary-item">
                    <div class="summary-value">$${totalActual.toLocaleString()}</div>
                    <div class="summary-label">Actual Revenue</div>
                  </div>
                  <div class="summary-item">
                    <div class="summary-value ${totalVariance >= 0 ? 'positive' : 'negative'}">$${totalVariance.toLocaleString()}</div>
                    <div class="summary-label">Variance</div>
                  </div>
                  <div class="summary-item">
                    <div class="summary-value">${overallPercentage.toFixed(1)}%</div>
                    <div class="summary-label">Achievement</div>
                  </div>
                </div>
              </div>
              
              <h2>Centre Breakdown</h2>
              <table>
                <thead>
                  <tr>
                    <th>Centre</th>
                    <th>State</th>
                    <th>Budget</th>
                    <th>Actual</th>
                    <th>Variance</th>
                    <th>% Achieved</th>
                  </tr>
                </thead>
                <tbody>
                  ${centreBreakdown.map(c => `
                    <tr>
                      <td>${c.centreName}</td>
                      <td>${c.centreState}</td>
                      <td>$${c.budget.toLocaleString()}</td>
                      <td>$${c.actual.toLocaleString()}</td>
                      <td class="${c.variance >= 0 ? 'positive' : 'negative'}">$${c.variance.toLocaleString()}</td>
                      <td>${c.percentAchieved.toFixed(1)}%</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
            </body>
            </html>
          `;
          
          // Generate PDF using pdfkit
          const PDFDocument = (await import('pdfkit')).default;
          const doc = new PDFDocument({ margin: 50 });
          const chunks: Buffer[] = [];
          
          doc.on('data', (chunk: Buffer) => chunks.push(chunk));
          
          // Title
          doc.fontSize(24).fillColor('#1e40af').text('Budget vs Actual Report', { align: 'center' });
          doc.moveDown(0.5);
          doc.fontSize(12).fillColor('#6b7280').text(
            `Financial Year ${input.financialYear - 1}-${input.financialYear} | ${filterState || 'All States'} | Generated: ${new Date().toLocaleDateString()}`,
            { align: 'center' }
          );
          doc.moveDown(2);
          
          // Summary Box
          doc.fontSize(14).fillColor('#1e40af').text('Summary', { underline: true });
          doc.moveDown(0.5);
          doc.fontSize(11).fillColor('#374151');
          doc.text(`Total Annual Budget: $${totalBudget.toLocaleString()}`);
          doc.text(`Total Actual Revenue: $${totalActual.toLocaleString()}`);
          doc.text(`Total Variance: $${totalVariance.toLocaleString()}`, { continued: false });
          doc.text(`Overall Achievement: ${overallPercentage.toFixed(1)}%`);
          doc.moveDown(2);
          
          // Centre Breakdown Table
          doc.fontSize(14).fillColor('#1e40af').text('Centre Breakdown', { underline: true });
          doc.moveDown(0.5);
          
          // Table headers
          const tableTop = doc.y;
          const colWidths = [150, 40, 80, 80, 80, 60];
          const headers = ['Centre', 'State', 'Budget', 'Actual', 'Variance', '% Achieved'];
          
          doc.fontSize(10).fillColor('#374151');
          let xPos = 50;
          headers.forEach((header, i) => {
            doc.text(header, xPos, tableTop, { width: colWidths[i], align: 'left' });
            xPos += colWidths[i];
          });
          
          doc.moveDown(0.5);
          doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke('#e5e7eb');
          doc.moveDown(0.3);
          
          // Table rows
          centreBreakdown.forEach(c => {
            const rowY = doc.y;
            xPos = 50;
            const rowData = [
              c.centreName.substring(0, 25),
              c.centreState,
              `$${c.budget.toLocaleString()}`,
              `$${c.actual.toLocaleString()}`,
              `$${c.variance.toLocaleString()}`,
              `${c.percentAchieved.toFixed(1)}%`
            ];
            rowData.forEach((cell, i) => {
              doc.text(cell, xPos, rowY, { width: colWidths[i], align: 'left' });
              xPos += colWidths[i];
            });
            doc.moveDown(0.8);
          });
          
          doc.end();
          
          // Wait for PDF to finish
          await new Promise<void>((resolve) => doc.on('end', resolve));
          const pdfBuffer = Buffer.concat(chunks);
          
          return {
            data: pdfBuffer.toString('base64'),
            filename: `Budget_Report_FY${input.financialYear - 1}-${input.financialYear}.pdf`,
            mimeType: 'application/pdf',
          };
        }
      }),
  }),

  // Budget Management
  budgets: router({
    list: adminProcedure.query(async () => {
      return await db.getAllBudgets();
    }),

    create: adminProcedure
      .input(z.object({
        siteId: z.number(),
        month: z.number().min(1).max(12),
        year: z.number(),
        budgetAmount: z.string(),
      }))
      .mutation(async ({ input }) => {
        return await db.createBudget(input);
      }),

    update: adminProcedure
      .input(z.object({
        id: z.number(),
        budgetAmount: z.string(),
      }))
      .mutation(async ({ input }) => {
        return await db.updateBudget(input.id, input.budgetAmount);
      }),

    delete: adminProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        return await db.deleteBudget(input.id);
      }),

    getBySite: adminProcedure
      .input(z.object({ siteId: z.number(), year: z.number() }))
      .query(async ({ input }) => {
        return await db.getBudgetsBySite(input.siteId, input.year);
      }),

    bulkImport: adminProcedure
      .input(z.object({
        budgets: z.array(z.object({
          siteId: z.number(),
          month: z.number().min(1).max(12),
          year: z.number(),
          budgetAmount: z.string(),
        })),
      }))
      .mutation(async ({ input }) => {
        return await db.bulkImportBudgets(input.budgets);
      }),

    // Financial Year Budget Management
    getFyPercentages: adminProcedure
      .input(z.object({ financialYear: z.number() }))
      .query(async ({ input }) => {
        const fyDb = await import("./fyBudgetDb");
        return await fyDb.getFyPercentages(input.financialYear);
      }),

    saveFyPercentages: adminProcedure
      .input(z.object({
        financialYear: z.number(),
        july: z.string(),
        august: z.string(),
        september: z.string(),
        october: z.string(),
        november: z.string(),
        december: z.string(),
        january: z.string(),
        february: z.string(),
        march: z.string(),
        april: z.string(),
        may: z.string(),
        june: z.string(),
      }))
      .mutation(async ({ input }) => {
        const fyDb = await import("./fyBudgetDb");
        return await fyDb.upsertFyPercentages(input);
      }),

    getCentreBudgetsForYear: adminProcedure
      .input(z.object({ financialYear: z.number() }))
      .query(async ({ input }) => {
        const fyDb = await import("./fyBudgetDb");
        return await fyDb.getCentreBudgetsForYear(input.financialYear);
      }),

    saveCentreBudget: adminProcedure
      .input(z.object({
        centreId: z.number(),
        financialYear: z.number(),
        annualBudget: z.string(),
      }))
      .mutation(async ({ input }) => {
        const fyDb = await import("./fyBudgetDb");
        return await fyDb.upsertCentreBudget(input);
      }),

    deleteCentreBudget: adminProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        const fyDb = await import("./fyBudgetDb");
        await fyDb.deleteCentreBudget(input.id);
        return { success: true };
      }),

    getAllCentresForBudget: adminProcedure
      .query(async () => {
        const fyDb = await import("./fyBudgetDb");
        return await fyDb.getAllCentresForBudget();
      }),

    getCentresWithoutBudget: adminProcedure
      .input(z.object({ financialYear: z.number() }))
      .query(async ({ input }) => {
        const fyDb = await import("./fyBudgetDb");
        return await fyDb.getCentresWithoutBudget(input.financialYear);
      }),

    bulkImportCentreBudgets: adminProcedure
      .input(z.object({
        financialYear: z.number(),
        data: z.array(z.object({
          centreName: z.string(),
          annualBudget: z.string(),
        })),
      }))
      .mutation(async ({ input }) => {
        const fyDb = await import("./fyBudgetDb");
        return await fyDb.bulkImportCentreBudgets(input.financialYear, input.data);
      }),
  }),

  // Third Line Categories (admin-managed)
  thirdLineCategories: router({
    list: publicProcedure.query(async () => {
      return await assetDb.getAllThirdLineCategories();
    }),
    
    listActive: publicProcedure.query(async () => {
      return await assetDb.getActiveThirdLineCategories();
    }),
    
    create: adminProcedure
      .input(z.object({
        name: z.string().min(1),
        displayOrder: z.number().optional(),
        isActive: z.boolean().optional(),
      }))
      .mutation(async ({ input }) => {
        const id = await assetDb.createThirdLineCategory(input);
        return { id };
      }),
    
    update: adminProcedure
      .input(z.object({
        id: z.number(),
        name: z.string().min(1).optional(),
        displayOrder: z.number().optional(),
        isActive: z.boolean().optional(),
      }))
      .mutation(async ({ input }) => {
        const { id, ...data } = input;
        await assetDb.updateThirdLineCategory(id, data);
        return { success: true };
      }),
    
    delete: adminProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        await assetDb.deleteThirdLineCategory(input.id);
        return { success: true };
      }),
  }),

  // Vacant Shops
  vacantShops: router({
    getByCentre: publicProcedure
      .input(z.object({ centreId: z.number() }))
      .query(async ({ input }) => {
        return await assetDb.getVacantShopsByCentre(input.centreId);
      }),
    
    getActiveByCentre: publicProcedure
      .input(z.object({ centreId: z.number() }))
      .query(async ({ input }) => {
        return await assetDb.getActiveVacantShopsByCentre(input.centreId);
      }),
    
    getById: publicProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        const shop = await assetDb.getVacantShopById(input.id);
        if (!shop) throw new TRPCError({ code: "NOT_FOUND", message: "Vacant shop not found" });
        return shop;
      }),
    
    create: adminProcedure
      .input(z.object({
        centreId: z.number(),
        shopNumber: z.string().min(1),
        totalSizeM2: z.string().optional(),
        dimensions: z.string().optional(),
        powered: z.boolean().optional(),
        description: z.string().optional(),
        imageUrl1: z.string().optional(),
        imageUrl2: z.string().optional(),
        pricePerWeek: z.string().optional(),
        pricePerMonth: z.string().optional(),
        floorLevelId: z.number().nullable().optional(),
        mapMarkerX: z.number().nullable().optional(),
        mapMarkerY: z.number().nullable().optional(),
        isActive: z.boolean().optional(),
      }))
      .mutation(async ({ input }) => {
        const id = await assetDb.createVacantShop(input);
        return { id };
      }),
    
    update: adminProcedure
      .input(z.object({
        id: z.number(),
        shopNumber: z.string().min(1).optional(),
        totalSizeM2: z.string().optional(),
        dimensions: z.string().optional(),
        powered: z.boolean().optional(),
        description: z.string().optional(),
        imageUrl1: z.string().optional(),
        imageUrl2: z.string().optional(),
        pricePerWeek: z.string().optional(),
        pricePerMonth: z.string().optional(),
        floorLevelId: z.number().nullable().optional(),
        mapMarkerX: z.number().nullable().optional(),
        mapMarkerY: z.number().nullable().optional(),
        isActive: z.boolean().optional(),
      }))
      .mutation(async ({ input }) => {
        const { id, ...data } = input;
        await assetDb.updateVacantShop(id, data);
        return { success: true };
      }),
    
    delete: adminProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        await assetDb.deleteVacantShop(input.id);
        return { success: true };
      }),

    uploadImage: adminProcedure
      .input(z.object({
        shopId: z.number(),
        imageSlot: z.number().min(1).max(2),
        base64Image: z.string(),
      }))
      .mutation(async ({ input }) => {
        const { processAssetImage } = await import('./imageProcessing');
        const { url } = await processAssetImage(
          input.base64Image,
          'vacant-shop',
          input.shopId,
          input.imageSlot
        );
        await assetDb.updateVacantShop(input.shopId, {
          [`imageUrl${input.imageSlot}`]: url,
        } as any);
        return { url };
      }),
  }),

  // Third Line Income
  thirdLineIncome: router({
    getByCentre: publicProcedure
      .input(z.object({ centreId: z.number() }))
      .query(async ({ input }) => {
        return await assetDb.getThirdLineIncomeByCentre(input.centreId);
      }),
    
    getActiveByCentre: publicProcedure
      .input(z.object({ centreId: z.number() }))
      .query(async ({ input }) => {
        return await assetDb.getActiveThirdLineIncomeByCentre(input.centreId);
      }),
    
    getById: publicProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        const asset = await assetDb.getThirdLineIncomeById(input.id);
        if (!asset) throw new TRPCError({ code: "NOT_FOUND", message: "Third line income asset not found" });
        return asset;
      }),
    
    create: adminProcedure
      .input(z.object({
        centreId: z.number(),
        assetNumber: z.string().min(1),
        categoryId: z.number(),
        dimensions: z.string().optional(),
        powered: z.boolean().optional(),
        description: z.string().optional(),
        imageUrl1: z.string().optional(),
        imageUrl2: z.string().optional(),
        pricePerWeek: z.string().optional(),
        pricePerMonth: z.string().optional(),
        floorLevelId: z.number().nullable().optional(),
        mapMarkerX: z.number().nullable().optional(),
        mapMarkerY: z.number().nullable().optional(),
        isActive: z.boolean().optional(),
      }))
      .mutation(async ({ input }) => {
        const id = await assetDb.createThirdLineIncome(input);
        return { id };
      }),
    
    update: adminProcedure
      .input(z.object({
        id: z.number(),
        assetNumber: z.string().min(1).optional(),
        categoryId: z.number().optional(),
        dimensions: z.string().optional(),
        powered: z.boolean().optional(),
        description: z.string().optional(),
        imageUrl1: z.string().optional(),
        imageUrl2: z.string().optional(),
        pricePerWeek: z.string().optional(),
        pricePerMonth: z.string().optional(),
        floorLevelId: z.number().nullable().optional(),
        mapMarkerX: z.number().nullable().optional(),
        mapMarkerY: z.number().nullable().optional(),
        isActive: z.boolean().optional(),
      }))
      .mutation(async ({ input }) => {
        const { id, ...data } = input;
        await assetDb.updateThirdLineIncome(id, data);
        return { success: true };
      }),
    
    delete: adminProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        await assetDb.deleteThirdLineIncome(input.id);
        return { success: true };
      }),

    uploadImage: adminProcedure
      .input(z.object({
        assetId: z.number(),
        imageSlot: z.number().min(1).max(2),
        base64Image: z.string(),
      }))
      .mutation(async ({ input }) => {
        const { processAssetImage } = await import('./imageProcessing');
        const { url } = await processAssetImage(
          input.base64Image,
          'third-line',
          input.assetId,
          input.imageSlot
        );
        await assetDb.updateThirdLineIncome(input.assetId, {
          [`imageUrl${input.imageSlot}`]: url,
        } as any);
        return { url };
      }),
  }),

  // Unified Assets Query
  assets: router({
    getByCentre: publicProcedure
      .input(z.object({
        centreId: z.number(),
        assetType: z.enum(["casual_leasing", "vacant_shops", "third_line", "all"]).optional(),
      }))
      .query(async ({ input }) => {
        return await assetDb.getAllAssetsByCentre(input.centreId, input.assetType || "all");
      }),
  }),

  // Vacant Shop Bookings
  vacantShopBookings: router({
    list: adminProcedure
      .input(z.object({
        status: z.enum(["pending", "confirmed", "cancelled", "completed", "rejected"]).optional(),
      }))
      .query(async ({ input }) => {
        return await assetDb.listVacantShopBookings(input.status);
      }),
    
    getByShop: publicProcedure
      .input(z.object({ vacantShopId: z.number() }))
      .query(async ({ input }) => {
        return await assetDb.getVacantShopBookingsByShop(input.vacantShopId);
      }),
    
    getByCentre: publicProcedure
      .input(z.object({ 
        centreId: z.number(),
        startDate: z.date().optional(),
        endDate: z.date().optional(),
      }))
      .query(async ({ input }) => {
        return await assetDb.getVacantShopBookingsByCentre(input.centreId, input.startDate, input.endDate);
      }),
    
    checkAvailability: publicProcedure
      .input(z.object({
        vacantShopId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
        excludeBookingId: z.number().optional(),
      }))
      .query(async ({ input }) => {
        const isAvailable = await assetDb.checkVacantShopAvailability(
          input.vacantShopId,
          input.startDate,
          input.endDate,
          input.excludeBookingId
        );
        return { available: isAvailable };
      }),
    
    getAvailabilityCalendar: publicProcedure
      .input(z.object({
        centreId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
      }))
      .query(async ({ input }) => {
        return await assetDb.getVacantShopAvailabilityCalendar(
          input.centreId,
          input.startDate,
          input.endDate
        );
      }),
    
    create: protectedProcedure
      .input(z.object({
        vacantShopId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
        totalAmount: z.string(),
        gstAmount: z.string(),
        gstPercentage: z.string(),
        ownerAmount: z.string(),
        platformFee: z.string(),
        customerNotes: z.string().optional(),
        paymentMethod: z.enum(["stripe", "invoice"]).optional(),
      }))
      .mutation(async ({ ctx, input }) => {
        // Check availability first
        const isAvailable = await assetDb.checkVacantShopAvailability(
          input.vacantShopId,
          input.startDate,
          input.endDate
        );
        
        if (!isAvailable) {
          throw new TRPCError({
            code: "CONFLICT",
            message: "This vacant shop is not available for the selected dates",
          });
        }
        
        // Generate booking number
        const bookingNumber = await assetDb.generateVacantShopBookingNumber(input.vacantShopId);
        
        // Get shop details for email
        const shop = await assetDb.getVacantShopById(input.vacantShopId);
        
        const id = await assetDb.createVacantShopBooking({
          bookingNumber,
          vacantShopId: input.vacantShopId,
          customerId: ctx.user.id,
          startDate: input.startDate,
          endDate: input.endDate,
          totalAmount: input.totalAmount,
          gstAmount: input.gstAmount,
          gstPercentage: input.gstPercentage,
          ownerAmount: input.ownerAmount,
          platformFee: input.platformFee,
          customerNotes: input.customerNotes,
          customerEmail: ctx.user.email || undefined,
          paymentMethod: input.paymentMethod || "stripe",
          status: "pending",
          requiresApproval: false,
        });
        
        // Send enquiry email notification
        if (shop && ctx.user.email) {
          const { sendVacantShopEnquiryEmail } = await import("./_core/bookingNotifications");
          const centre = await db.getShoppingCentreById(shop.centreId);
          await sendVacantShopEnquiryEmail(
            shop.shopNumber,
            ctx.user.name || "Valued Customer",
            ctx.user.email,
            centre?.name || "Shopping Centre",
            input.startDate,
            input.endDate,
            input.customerNotes || ""
          );
        }
        
        return { id, bookingNumber };
      }),
    
    updateStatus: adminProcedure
      .input(z.object({
        id: z.number(),
        status: z.enum(["pending", "confirmed", "cancelled", "completed", "rejected"]),
        rejectionReason: z.string().optional(),
      }))
      .mutation(async ({ ctx, input }) => {
        const booking = await assetDb.getVacantShopBookingById(input.id);
        if (!booking) {
          throw new TRPCError({ code: "NOT_FOUND", message: "Booking not found" });
        }
        
        const updateData: any = { status: input.status };
        
        if (input.status === "confirmed") {
          updateData.approvedBy = ctx.user.id;
          updateData.approvedAt = new Date();
        }
        
        if (input.status === "rejected" && input.rejectionReason) {
          updateData.rejectionReason = input.rejectionReason;
        }
        
        await assetDb.updateVacantShopBooking(input.id, updateData);
        
        // Send confirmation email
        if (input.status === "confirmed" && booking.customerEmail) {
          const shop = await assetDb.getVacantShopById(booking.vacantShopId);
          const centre = await db.getShoppingCentreById(shop?.centreId || 0);
          const { sendVSThirdLineConfirmationEmail } = await import("./_core/bookingNotifications");
          await sendVSThirdLineConfirmationEmail(
            "vacant_shop",
            shop?.shopNumber || "Vacant Shop",
            booking.customerEmail,
            booking.customerEmail,
            centre?.name || "Shopping Centre",
            booking.startDate,
            booking.endDate,
            booking.totalAmount
          );
        }
        
        // Send rejection email
        if (input.status === "rejected" && booking.customerEmail && input.rejectionReason) {
          const shop = await assetDb.getVacantShopById(booking.vacantShopId);
          const centre = await db.getShoppingCentreById(shop?.centreId || 0);
          const { sendVSThirdLineRejectionEmail } = await import("./_core/bookingNotifications");
          await sendVSThirdLineRejectionEmail(
            "vacant_shop",
            shop?.shopNumber || "Vacant Shop",
            booking.customerEmail,
            booking.customerEmail,
            centre?.name || "Shopping Centre",
            booking.startDate,
            booking.endDate,
            input.rejectionReason
          );
        }
        
        return { success: true };
      }),
  }),

  // Third Line Bookings
  thirdLineBookings: router({
    list: adminProcedure
      .input(z.object({
        status: z.enum(["pending", "confirmed", "cancelled", "completed", "rejected"]).optional(),
      }))
      .query(async ({ input }) => {
        return await assetDb.listThirdLineBookings(input.status);
      }),
    
    getByAsset: publicProcedure
      .input(z.object({ thirdLineIncomeId: z.number() }))
      .query(async ({ input }) => {
        return await assetDb.getThirdLineBookingsByAsset(input.thirdLineIncomeId);
      }),
    
    getByCentre: publicProcedure
      .input(z.object({ 
        centreId: z.number(),
        startDate: z.date().optional(),
        endDate: z.date().optional(),
      }))
      .query(async ({ input }) => {
        return await assetDb.getThirdLineBookingsByCentre(input.centreId, input.startDate, input.endDate);
      }),
    
    checkAvailability: publicProcedure
      .input(z.object({
        thirdLineIncomeId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
        excludeBookingId: z.number().optional(),
      }))
      .query(async ({ input }) => {
        const isAvailable = await assetDb.checkThirdLineAvailability(
          input.thirdLineIncomeId,
          input.startDate,
          input.endDate,
          input.excludeBookingId
        );
        return { available: isAvailable };
      }),
    
    getAvailabilityCalendar: publicProcedure
      .input(z.object({
        centreId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
      }))
      .query(async ({ input }) => {
        return await assetDb.getThirdLineAvailabilityCalendar(
          input.centreId,
          input.startDate,
          input.endDate
        );
      }),
    
    create: protectedProcedure
      .input(z.object({
        thirdLineIncomeId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
        totalAmount: z.string(),
        gstAmount: z.string(),
        gstPercentage: z.string(),
        ownerAmount: z.string(),
        platformFee: z.string(),
        customerNotes: z.string().optional(),
        paymentMethod: z.enum(["stripe", "invoice"]).optional(),
      }))
      .mutation(async ({ ctx, input }) => {
        // Check availability first
        const isAvailable = await assetDb.checkThirdLineAvailability(
          input.thirdLineIncomeId,
          input.startDate,
          input.endDate
        );
        
        if (!isAvailable) {
          throw new TRPCError({
            code: "CONFLICT",
            message: "This third line asset is not available for the selected dates",
          });
        }
        
        // Generate booking number
        const bookingNumber = await assetDb.generateThirdLineBookingNumber(input.thirdLineIncomeId);
        
        // Get asset details for email
        const asset = await assetDb.getThirdLineIncomeById(input.thirdLineIncomeId);
        
        const id = await assetDb.createThirdLineBooking({
          bookingNumber,
          thirdLineIncomeId: input.thirdLineIncomeId,
          customerId: ctx.user.id,
          startDate: input.startDate,
          endDate: input.endDate,
          totalAmount: input.totalAmount,
          gstAmount: input.gstAmount,
          gstPercentage: input.gstPercentage,
          ownerAmount: input.ownerAmount,
          platformFee: input.platformFee,
          customerNotes: input.customerNotes,
          customerEmail: ctx.user.email || undefined,
          paymentMethod: input.paymentMethod || "stripe",
          status: "pending",
          requiresApproval: false,
        });
        
        // Send enquiry email notification
        if (asset && ctx.user.email) {
          const { sendThirdLineEnquiryEmail } = await import("./_core/bookingNotifications");
          const centre = await db.getShoppingCentreById(asset.centreId);
          const categoryName = asset.categoryName || "Third Line Asset";
          await sendThirdLineEnquiryEmail(
            asset.assetNumber,
            categoryName,
            ctx.user.name || "Valued Customer",
            ctx.user.email,
            centre?.name || "Shopping Centre",
            input.startDate,
            input.endDate,
            input.customerNotes || ""
          );
        }
        
        return { id, bookingNumber };
      }),
    
    updateStatus: adminProcedure
      .input(z.object({
        id: z.number(),
        status: z.enum(["pending", "confirmed", "cancelled", "completed", "rejected"]),
        rejectionReason: z.string().optional(),
      }))
      .mutation(async ({ ctx, input }) => {
        const booking = await assetDb.getThirdLineBookingById(input.id);
        if (!booking) {
          throw new TRPCError({ code: "NOT_FOUND", message: "Booking not found" });
        }
        
        const updateData: any = { status: input.status };
        
        if (input.status === "confirmed") {
          updateData.approvedBy = ctx.user.id;
          updateData.approvedAt = new Date();
        }
        
        if (input.status === "rejected" && input.rejectionReason) {
          updateData.rejectionReason = input.rejectionReason;
        }
        
        await assetDb.updateThirdLineBooking(input.id, updateData);
        
        // Send confirmation email
        if (input.status === "confirmed" && booking.customerEmail) {
          const asset = await assetDb.getThirdLineIncomeById(booking.thirdLineIncomeId);
          const centre = await db.getShoppingCentreById(asset?.centreId || 0);
          const { sendVSThirdLineConfirmationEmail } = await import("./_core/bookingNotifications");
          await sendVSThirdLineConfirmationEmail(
            "third_line",
            asset?.assetNumber || "Third Line Asset",
            booking.customerEmail,
            booking.customerEmail,
            centre?.name || "Shopping Centre",
            booking.startDate,
            booking.endDate,
            booking.totalAmount,
            asset?.categoryName || undefined
          );
        }
        
        // Send rejection email
        if (input.status === "rejected" && booking.customerEmail && input.rejectionReason) {
          const asset = await assetDb.getThirdLineIncomeById(booking.thirdLineIncomeId);
          const centre = await db.getShoppingCentreById(asset?.centreId || 0);
          const { sendVSThirdLineRejectionEmail } = await import("./_core/bookingNotifications");
          await sendVSThirdLineRejectionEmail(
            "third_line",
            asset?.assetNumber || "Third Line Asset",
            booking.customerEmail,
            booking.customerEmail,
            centre?.name || "Shopping Centre",
            booking.startDate,
            booking.endDate,
            input.rejectionReason,
            asset?.categoryName || undefined
          );
        }
        
        return { success: true };
      }),
  }),

  // Admin Booking Management
  adminBooking: router({
    // Get site availability grid for a centre and month
    getAvailabilityGrid: adminProcedure
      .input(z.object({
        centreId: z.number(),
        year: z.number(),
        month: z.number().min(1).max(12),
      }))
      .query(async ({ input }) => {
        const { getSiteAvailabilityGrid } = await import('./adminBookingDb');
        return await getSiteAvailabilityGrid(input.centreId, input.year, input.month);
      }),

    // Check for booking overlaps
    checkOverlaps: adminProcedure
      .input(z.object({
        siteId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
        excludeBookingId: z.number().optional(),
      }))
      .query(async ({ input }) => {
        const { checkBookingOverlaps } = await import('./adminBookingDb');
        return await checkBookingOverlaps(
          input.siteId,
          input.startDate,
          input.endDate,
          input.excludeBookingId
        );
      }),

    // Get users for booking dropdown
    getUsers: adminProcedure.query(async () => {
      const { getUsersForAdminBooking } = await import('./adminBookingDb');
      return await getUsersForAdminBooking();
    }),

    // Calculate booking cost preview
    calculateCost: adminProcedure
      .input(z.object({
        siteId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
      }))
      .query(async ({ input }) => {
        const site = await db.getSiteById(input.siteId);
        if (!site) throw new TRPCError({ code: 'NOT_FOUND', message: 'Site not found' });

        const { calculateBookingCost } = await import('./bookingCalculation');
        const { totalAmount, weekdayCount, weekendCount, seasonalDays } = await calculateBookingCost(
          site,
          input.startDate,
          input.endDate
        );

        // Get GST rate
        const gstValue = await getConfigValue('gst_percentage');
        const gstRate = gstValue ? Number(gstValue) / 100 : 0.1;
        const gstAmount = totalAmount * gstRate;

        // Get centre and owner for commission
        const centre = await db.getShoppingCentreById(site.centreId);
        if (!centre) throw new TRPCError({ code: 'NOT_FOUND', message: 'Centre not found' });
        
        const owner = await db.getOwnerById(centre.ownerId);
        if (!owner) throw new TRPCError({ code: 'NOT_FOUND', message: 'Owner not found' });

        const platformFee = totalAmount * (Number(owner.commissionPercentage) / 100);
        const ownerAmount = totalAmount - platformFee;

        return {
          totalAmount,
          gstAmount,
          gstPercentage: gstRate * 100,
          ownerAmount,
          platformFee,
          weekdayCount,
          weekendCount,
          seasonalDays: seasonalDays || [],
          pricePerDay: Number(site.pricePerDay),
          weekendPricePerDay: site.weekendPricePerDay ? Number(site.weekendPricePerDay) : null,
          pricePerWeek: Number(site.pricePerWeek),
        };
      }),

    // Create admin booking
    create: adminProcedure
      .input(z.object({
        centreId: z.number(),
        siteId: z.number(),
        customerId: z.number(),
        startDate: z.date(),
        endDate: z.date(),
        totalAmount: z.number(),
        tablesRequested: z.number().default(0),
        chairsRequested: z.number().default(0),
        invoiceOverride: z.boolean().default(false),
        adminComments: z.string().optional(),
        usageCategoryId: z.number().optional(),
        additionalCategoryText: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        // Check for overlaps
        const { checkBookingOverlaps, createAdminBooking } = await import('./adminBookingDb');
        const overlaps = await checkBookingOverlaps(input.siteId, input.startDate, input.endDate);
        if (overlaps.length > 0) {
          throw new TRPCError({
            code: 'CONFLICT',
            message: `Booking conflicts with existing bookings: ${overlaps.map(o => o.bookingNumber).join(', ')}`,
          });
        }

        // Get site and centre info
        const site = await db.getSiteById(input.siteId);
        if (!site) throw new TRPCError({ code: 'NOT_FOUND', message: 'Site not found' });

        const centre = await db.getShoppingCentreById(site.centreId);
        if (!centre) throw new TRPCError({ code: 'NOT_FOUND', message: 'Centre not found' });

        const owner = await db.getOwnerById(centre.ownerId);
        if (!owner) throw new TRPCError({ code: 'NOT_FOUND', message: 'Owner not found' });

        // Get user payment method
        const customer = await db.getUserById(input.customerId);
        if (!customer) throw new TRPCError({ code: 'NOT_FOUND', message: 'Customer not found' });

        // Calculate GST and fees
        const gstValue = await getConfigValue('gst_percentage');
        const gstRate = gstValue ? Number(gstValue) / 100 : 0.1;
        const gstAmount = input.totalAmount * gstRate;
        const platformFee = input.totalAmount * (Number(owner.commissionPercentage) / 100);
        const ownerAmount = input.totalAmount - platformFee;

        // Generate booking number
        const { getCentreCodeForBooking } = await import('./centreCodeHelper');
        const centreCode = getCentreCodeForBooking(centre);
        const dateStr = new Date(input.startDate).toISOString().split('T')[0].replace(/-/g, '');
        const randomSeq = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
        const bookingNumber = `${centreCode}-${dateStr}-${randomSeq}`;

        // Create booking
        const { bookingId } = await createAdminBooking({
          centreId: input.centreId,
          siteId: input.siteId,
          customerId: input.customerId,
          startDate: input.startDate,
          endDate: input.endDate,
          totalAmount: input.totalAmount.toFixed(2),
          gstAmount: gstAmount.toFixed(2),
          gstPercentage: (gstRate * 100).toFixed(2),
          ownerAmount: ownerAmount.toFixed(2),
          platformFee: platformFee.toFixed(2),
          tablesRequested: input.tablesRequested,
          chairsRequested: input.chairsRequested,
          paymentMethod: customer.canPayByInvoice ? 'invoice' : 'stripe',
          invoiceOverride: input.invoiceOverride,
          adminComments: input.adminComments,
          usageCategoryId: input.usageCategoryId,
          additionalCategoryText: input.additionalCategoryText,
          createdByAdminId: ctx.user.id,
          bookingNumber,
        });

        // Send confirmation email
        try {
          if (customer.email) {
            await sendBookingConfirmationEmail({
              bookingNumber,
              customerName: customer.name || 'Customer',
              customerEmail: customer.email,
              centreName: centre.name,
              siteNumber: site.siteNumber,
              startDate: input.startDate,
              endDate: input.endDate,
              totalAmount: input.totalAmount,
            });
          }
        } catch (emailError) {
          console.error('Failed to send confirmation email:', emailError);
        }

        return { bookingId, bookingNumber };
      }),

    // Update admin booking
    update: adminProcedure
      .input(z.object({
        bookingId: z.number(),
        startDate: z.date().optional(),
        endDate: z.date().optional(),
        totalAmount: z.number().optional(),
        tablesRequested: z.number().optional(),
        chairsRequested: z.number().optional(),
        adminComments: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const { bookingId, ...updates } = input;

        // If dates changed, check for overlaps
        if (updates.startDate || updates.endDate) {
          const booking = await db.getBookingById(bookingId);
          if (!booking) throw new TRPCError({ code: 'NOT_FOUND', message: 'Booking not found' });

          const { checkBookingOverlaps } = await import('./adminBookingDb');
          const overlaps = await checkBookingOverlaps(
            booking.siteId,
            updates.startDate || booking.startDate,
            updates.endDate || booking.endDate,
            bookingId
          );
          if (overlaps.length > 0) {
            throw new TRPCError({
              code: 'CONFLICT',
              message: `Date change conflicts with existing bookings: ${overlaps.map(o => o.bookingNumber).join(', ')}`,
            });
          }
        }

        // Recalculate amounts if totalAmount changed
        let gstAmount: string | undefined;
        let ownerAmount: string | undefined;
        let platformFee: string | undefined;

        if (updates.totalAmount !== undefined) {
          const booking = await db.getBookingById(bookingId);
          if (!booking) throw new TRPCError({ code: 'NOT_FOUND', message: 'Booking not found' });

          const site = await db.getSiteById(booking.siteId);
          if (!site) throw new TRPCError({ code: 'NOT_FOUND', message: 'Site not found' });

          const centre = await db.getShoppingCentreById(site.centreId);
          if (!centre) throw new TRPCError({ code: 'NOT_FOUND', message: 'Centre not found' });

          const owner = await db.getOwnerById(centre.ownerId);
          if (!owner) throw new TRPCError({ code: 'NOT_FOUND', message: 'Owner not found' });

          const gstValue = await getConfigValue('gst_percentage');
          const gstRate = gstValue ? Number(gstValue) / 100 : 0.1;
          gstAmount = (updates.totalAmount * gstRate).toFixed(2);
          platformFee = (updates.totalAmount * (Number(owner.commissionPercentage) / 100)).toFixed(2);
          ownerAmount = (updates.totalAmount - Number(platformFee)).toFixed(2);
        }

        const { updateAdminBooking } = await import('./adminBookingDb');
        await updateAdminBooking(
          bookingId,
          {
            startDate: updates.startDate,
            endDate: updates.endDate,
            totalAmount: updates.totalAmount?.toFixed(2),
            gstAmount,
            ownerAmount,
            platformFee,
            tablesRequested: updates.tablesRequested,
            chairsRequested: updates.chairsRequested,
            adminComments: updates.adminComments,
          },
          ctx.user.id
        );

        return { success: true };
      }),

    // Get booking audit history
    getAuditHistory: adminProcedure
      .input(z.object({ bookingId: z.number() }))
      .query(async ({ input }) => {
        const { getBookingAuditHistory } = await import('./adminBookingDb');
        return await getBookingAuditHistory(input.bookingId);
      }),
  }),
});

export type AppRouter = typeof appRouter;
